<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>静态成员</title>
    <url>/2023/02/12/C++/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>我们可以使用 <strong>static</strong> 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>
<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<h1 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h1><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。</p>
<p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
<p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>
<blockquote>
<p><strong>静态成员函数与普通成员函数的区别：</strong></p>
<ul>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/07/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="任务列表语法"><a href="#任务列表语法" class="headerlink" title="任务列表语法"></a>任务列表语法</h1><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<ul>
<li><input checked disabled type="checkbox"> Write the press release</li>
<li><input disabled type="checkbox"> Update the website</li>
<li><input disabled type="checkbox"> Contact the media</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GDB调试忽略信号</title>
    <url>/2023/02/16/GDB/%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="GDB调试忽略信号"><a href="#GDB调试忽略信号" class="headerlink" title="GDB调试忽略信号"></a>GDB调试忽略信号</h1><p>在linux平台，用gdb调试程序时，可以在gdb attach到运行中程序后，用以下命令忽略一些不关注的信号：</p>
<p>handle SIGUSR2 noprint nostop</p>
<p>handle SIGPIPE noprint nostop</p>
<p><img src="/images/GDB_1.png"></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>内联函数</title>
    <url>/2023/02/12/C++/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>C++ <strong>内联函数</strong>是通常与类一起使用。如果一个函数是内联的，那么<strong>在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方</strong>,对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输出日志记录</title>
    <url>/2023/02/16/GDB/%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="输出日志记录"><a href="#输出日志记录" class="headerlink" title="输出日志记录"></a>输出日志记录</h1><blockquote>
<p>(gdb) set logging file fileName 设置文件名，文件默认生成在运行gdb命令的目录下；<br>(gdb) set logging on 启动日志记录；<br>(gdb) set height 0 这样gdb需要多行输出时，就会全部输出，中间不会暂停；<br>(gdb) set print elements 0 这样gdb在打印时就没有默认为200个元素的长度限制；<br>(gdb) thread apply all bt 在这里去实际操作，所需要的gdb命令<br>(gdb) set logging off  </p>
</blockquote>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>位域</title>
    <url>/2023/02/12/C/%E4%BD%8D%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><h1 id="让人疑惑的C语言位域-知乎"><a href="#让人疑惑的C语言位域-知乎" class="headerlink" title="让人疑惑的C语言位域 - 知乎"></a>让人疑惑的C语言位域 - 知乎</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>在实际的应用中，有些数据的存储只需要几个二进制位，而不需要一个字节或几个字节，比如：电灯接通电源的状态，只有通电和未通电两种状态，用 1 和 0 就可以表示，为了满足这种需求，C 语言中引入了位域的概念 位…</p>
</blockquote>
<hr>
<p>在实际的应用中，有些数据的存储只需要几个二进制位，而不需要一个字节或几个字节，比如：电灯接通电源的状态，只有通电和未通电两种状态，用 1 和 0 就可以表示，为了满足这种需求，C 语言中引入了位域的概念</p>
<h3 id="位域是什么"><a href="#位域是什么" class="headerlink" title="位域是什么"></a>位域是什么</h3><p>位域是一种数据结构，可以把数据以二进制位的形式紧凑的存储，它允许程序对此结构的位进行操作</p>
<p>在计算机早期，内存是非常稀缺的，需要尽可能的节省每一个字节，所以，C 语言中就出现了能针对二进制位进行操作的位域</p>
<h3 id="为什么要用位域"><a href="#为什么要用位域" class="headerlink" title="为什么要用位域"></a>为什么要用位域</h3><p>位域这种数据结构，可以最大限度的节省存储空间，对于一些非常频繁的操作，需要尽可能的减少操作的数据，比如：在开发网络应用时，数据的序列化和反序列化是很频繁的，如果能减少数据的长度，对提升数据打包效率是很有帮助的</p>
<p>位域的出现，让我们可以用变量名代表某些bit，并通过变量名获取和设置 bit 的值，而不是通过晦涩难理解的位操作来进行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct field</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char b0 : 3,</span><br><span class="line">                  b1 : 2,</span><br><span class="line">                  b2 : 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct field bf;</span><br><span class="line">bf.b1 = 3;</span><br></pre></td></tr></table></figure>

<p>通过位域设置中间 2 个bit 的值，只需要设置结构体中 <code>b1</code> 字段值即可，如果使不用位域字段，就需要进行位的 “或” 和 “与” 运算</p>
<h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>C 语言中，位域的表示形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct bitfield</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int b0 : n0,</span><br><span class="line">                 b1 : n1,</span><br><span class="line">                 b2 : n2,</span><br><span class="line">                 ...</span><br><span class="line">                 bn : nk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>b0、b1、b2 ... bn</code> 表示位域成员，<code>n0、n1、n2 ... nk</code> 表示成员占用多少个 bit</p>
<p>位域表示的范围通常不能超过其所依附类型所能表示的 bit 数，比如：上面 <code>bitfield</code> 结构体中 位域所依附的类型是 <code>unsigned int</code>, 最大能表示 32 个 bit，也就是说，<code>n0、n1、n2 ... nk</code> 总 bit 数不能超过 32，每个成员超过指定 bit 表示的最大数值时会被截断，具体请看下面的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct fields</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:7;</span><br><span class="line">        unsigned short b:5;</span><br><span class="line">        unsigned char c:4;</span><br><span class="line">        </span><br><span class="line">    &#125;fs;</span><br><span class="line"></span><br><span class="line">    fs.a = 0x8F;</span><br><span class="line">    fs.b = 0x1A;</span><br><span class="line">    fs.c = 0x19;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%#x, %#x, %#x \n&quot;,fs.a, fs.b, fs.c);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>gcc -g -o bitfield bitfield.c</code> 编译并运行，结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost]# ./bitfield                   </span><br><span class="line">0xf, 0x1a, 0x9</span><br></pre></td></tr></table></figure>

<p>字段 <code>a</code> 赋值为 <code>0x8F</code> 对应的二进制为 <strong>1000 1111</strong>，由于 <code>a</code> 只有 7 个bit，给它赋的值超出了限定的位数，超出部分被丢弃，保留低 7 位，最终结果为 <strong>000 1111</strong> ，换成十六进制是 <strong>0xf</strong></p>
<p>字段 <code>b</code> 赋值为 <code>0x1A</code> 对应的二进制为 <strong>1 1010</strong>， <code>b</code> 包含 5 个bit，取结果中的低 5 位，最终结果为 <strong>1 1010</strong> ，换成十六进制是 <strong>0x1a</strong> , 输出结果和赋值相同，即没有超出限定 bit 数</p>
<p>字段 <code>c</code> 赋值为 <code>0x19</code> 对应的二进制为 <strong>1</strong> <strong>1001</strong>，由于 <code>c</code> 只有 4 个bit，给它赋的值超出了限定的位数，超出部分被丢弃，保留低 4 位，最终结果为 <strong>1001</strong> ，换成十六进制是 <strong>0x9</strong></p>
<p>位域的使用有一定的限制，机器最小粒度的寻址单位是字节，我们无法像获得某一个字节的地址一样去获得某个 bit 的地址，下面是一个错误的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct fields</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:7;</span><br><span class="line">        unsigned short b:5;</span><br><span class="line">        unsigned char c:4;</span><br><span class="line">    &#125;fs;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%p\n&quot;,&amp;fs.a);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码功能是打印出成员 <code>a</code> 的地址，它无法通过编译，错误如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitfield.c: 在函数‘main’中:</span><br><span class="line">bitfield.c:11:5: 错误：无法取得位段‘a’的地址</span><br><span class="line">     printf(&quot;%p\n&quot;,&amp;fs.a);</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure>

<h3 id="位域的存储"><a href="#位域的存储" class="headerlink" title="位域的存储"></a>位域的存储</h3><p>C 标准中只允许 <code>unsigned int</code>、<code>signed int</code>、<code>int</code> 类型的位域申明，后面又增加了 <code>bool</code> 类型的支持，一些编译器像 <code>gcc</code>、<code>msvc</code>等自行加入了一些扩展，使得其他的类型(<code>short、char</code>等)也支持位域</p>
<p>位域的存储跟编译器相关，不同的编译器，存储位域的方式可能不一样，总的来说可以分成下面几类</p>
<p><strong>1、相邻位域成员，它们的类型相同时</strong></p>
<p>如果它们的 bit 数之和小于等于所依附类型的 bit 数，那么，后面的成员紧接着前面的成员存储</p>
<p>如果它们的 bit 数之和大于所依附类型的 bit 数，那么超过的成员会存储到新的存储单元中，新存储单元会偏移成员所依附类型的 sizeof 字节数</p>
<p>以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned short b:4;</span><br><span class="line">        unsigned short c:2;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost]# ./bitfield                   </span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><code>a 、b、c</code> 字段都是 <code>unsigned short</code> 类型，它们的 bit 数之和为 <strong>10 + 4 + 2 &#x3D; 16</strong>, 刚好等于 <strong>unsigned short</strong> 的 bit 数，所以它们会紧凑的存储，没有任何空隙</p>
<p>如果把 <code>a</code> 的 bit 数改成 11，即 **unsigned short a:11;**，此时，<code>a</code> 和 <code>b</code> 的 bit 数之和为 <strong>11 + 4 &#x3D; 15</strong>，没有超过 <code>unsigned short</code> 的 bit 数</p>
<p>如果再加上 <code>c</code> 的 bit 数，结果变成了 <strong>17</strong>，超过了 <code>unsigned short</code> 的 bit 数，这种情况下，<code>a</code> 和 <code>b</code> 还是会紧凑的存储，而 <code>c</code> 会存储到新的存储单元中，新的存储单元字节数为 <code>sizeof(unsigned short) = 2</code>， 所以此时 <strong>sizeof(fg)</strong> 是 <strong>4</strong></p>
<p><strong>2、相邻位域成员，它们的类型不同时</strong></p>
<p>这种情况跟具体的编译器相关，以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned char b:4;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码分别用 gcc4.8.5 和 vs2013 进行编译运行，结果如下</p>
<p>gcc的结果</p>
<p><img src="https://pic1.zhimg.com/v2-d24b60824986660fedafe38d419a983c_b.png"></p>
<p>vs2013的结果</p>
<p><img src="https://pic4.zhimg.com/v2-bbd2e82b112cd1c50f3bf58278c4a41f_b.jpg"></p>
<p>可以看到，当相邻位域成员所依附的类型不同时，不同的编译器产生的结果是不一样的</p>
<p>在 gcc 下的运行结果是 2 ，表示 <code>a</code> 和 <code>b</code> 还是紧凑存储的</p>
<p>而在 vs2013 下运行的结果是 4，这说明 <code>a</code> 和 <code>b</code> 完全按照他们所依附的类型来存储，此时位域没有进行压缩存储</p>
<p><strong>3、位域成员之间存在非位域成员时</strong></p>
<p>这种情况 gcc 和 vs2013 都不会进行压缩存储，按照内存对齐的规则来存储</p>
<p>还是以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned int i;</span><br><span class="line">        unsigned char b:4;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码分别用 gcc4.8.5 和 vs2013 进行编译运行，结果如下</p>
<p>gcc的结果</p>
<p><img src="https://pic2.zhimg.com/v2-7cc4101dd6c9bfb9b5355545ab9ad28d_b.png"></p>
<p>vs2013的结果</p>
<p><img src="https://pic2.zhimg.com/v2-0232a27563e369319790c6cdc634cba5_b.jpg"></p>
<p>不管在 gcc 还是在 vs2013 下，结果都相同，为了提高访问效率，成员按照 4 字节对齐，所以 <code>sizeof(fg)</code> 结果是 12</p>
<p><strong>现在位域使用得也比较少了，大概有以下几个的原因</strong></p>
<p>1、早期计算机内存很稀缺，在内存的使用上需要精打细算，但是，现代的计算机内存容量有了很大的提升，一般不需要为了节省几个字节而使用内存更加紧凑的位域</p>
<p>2、通过前面的介绍，我们知道结构体中位域的存储是跟编译器相关，这就导致了它的可移植性比较差</p>
<h3 id="匿名位域"><a href="#匿名位域" class="headerlink" title="匿名位域"></a>匿名位域</h3><p>位域成员可以不指定名字，只给出成员的数据类型以及占用的 bit 数，称作匿名位域</p>
<p>匿名位域字段只是起填充 bit，调整成员位置的作用，并无实际的意义</p>
<p>因为没有指定成员名字，所以也不能使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">    unsigned short a:10,</span><br><span class="line">                    :6; //匿名位域,不能使用</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面例子中，如果没有匿名位域的话，<code>sizeof(fields)</code> 的结果为 <strong>2</strong>，加入 <strong>6</strong> 个 bit 的填充以后，<code>a</code> 和 <code>b</code> 将分开存储， <code>sizeof(fields)</code> 的结果变成了 <strong>4</strong></p>
<p>我们还可以通过匿名0长度的位域字段来强制位域存储到下一个存储单元中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short a:10;</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的结构体本来可以全部存储到一个 <strong>2</strong> 字节的存储单元中，如果我们想让 <code>a</code> 和 <code>b</code> 存储到不同的存储单元中，可以在结构体中加入一个匿名的 0 长度的位域字段来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short a:10;</span><br><span class="line">    unsigned short  :0;</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样申明后，<code>sizeof(struct fields)</code> 就变成 <strong>4</strong> 了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文讲述了位域的基础，使用以及存储，其中位域的存储跟具体的编译器实现相关，这一点务必要注意，否则版本移植的时候要趟”坑”</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell IF语法</title>
    <url>/2023/02/27/Shell/if/</url>
    <content><![CDATA[<h1 id="SHELL-IF-语法"><a href="#SHELL-IF-语法" class="headerlink" title="SHELL IF 语法"></a>SHELL IF 语法</h1><p>if [ -f file ]; then<br>   echo “yes yes yes”<br>elif [ -z file ]; then<br>   echo “yes yes”<br>else<br>   echo “nonono”<br>fi</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>柔性数组</title>
    <url>/2023/02/16/C/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h1><h2 id="柔性数组定义"><a href="#柔性数组定义" class="headerlink" title="柔性数组定义"></a>柔性数组定义</h2><p>C99中，结构体中<strong>最后一个元素</strong>允许是未知大小的数组，这个成员叫做结构体的柔性数组成员。</p>
<p>柔型数组有两种定义方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. typedef struct st_type</span><br><span class="line">2. &#123;</span><br><span class="line">3.  int i;</span><br><span class="line">4.  int a[0];//柔性数组成员</span><br><span class="line">5. &#125;type_a;</span><br></pre></td></tr></table></figure>

<p>有些编译器会报错无法编译可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. typedef struct st_type</span><br><span class="line">2. &#123;</span><br><span class="line">3.  int i;</span><br><span class="line">4.  int a[];//柔性数组成员</span><br><span class="line">5. &#125;type_a;</span><br></pre></td></tr></table></figure>

<h2 id="柔性数组的特点"><a href="#柔性数组的特点" class="headerlink" title="柔性数组的特点"></a>柔性数组的特点</h2><p>（1）结构中的柔性数组成员 前面必须至少包含一个其他成员（从上面的代码可以看出）</p>
<p>（2）sizeof( )返回的这种结构大小不包括柔性数组的内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. typedef struct st_type</span><br><span class="line">4. &#123;</span><br><span class="line">5.  int i;</span><br><span class="line">6.  int a[0];//柔性数组成员</span><br><span class="line">7. &#125;type_a;</span><br><span class="line">8. </span><br><span class="line">9. int main()</span><br><span class="line">10. &#123;</span><br><span class="line">11.   printf(&quot;sizeof(type_a) = %d\n&quot;, sizeof(type_a));</span><br><span class="line">12.   return 0;</span><br><span class="line">13. &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为4可以看出特点(2) : 返回的结构大小不包括柔性数组的大小</p>
<p><img src="/images/C_1.png"></p>
<p>（3）包含柔型数组成员的结构用malloc( )函数进行内存的动态分配，并且分配的内存应该大于结构的大小。以适应柔型数组的预期大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. #include&lt;stdlib.h&gt;</span><br><span class="line">4. typedef struct st_type</span><br><span class="line">5. &#123;</span><br><span class="line">6.  int i;</span><br><span class="line">7.  int a[0];//柔性数组成员</span><br><span class="line">8. &#125;type_a;</span><br><span class="line">9. </span><br><span class="line">10. int main()</span><br><span class="line">11. &#123;</span><br><span class="line">12.   type_a* s = (type_a*)malloc(sizeof(type_a) + 10 * sizeof(int));//根据特点3，malloc申请的空间应该比结构体大小要大</span><br><span class="line">13.   if (s != NULL)</span><br><span class="line">14.   &#123;</span><br><span class="line">15.     s-&gt;i = 10;</span><br><span class="line">16.     int j = 0;</span><br><span class="line">17.     for (j = 0; j &lt; 10; j++)</span><br><span class="line">18.     &#123;</span><br><span class="line">19.       s-&gt;a[j] = j;</span><br><span class="line">20.     &#125;</span><br><span class="line">21.   &#125;</span><br><span class="line">22. </span><br><span class="line">23.   return 0;</span><br><span class="line">24. &#125;</span><br><span class="line">25.</span><br></pre></td></tr></table></figure>

<p><img src="/images/C_2.png"></p>
<p>VS2019   F10    监视内存，输入s ，内存如下所示：</p>
<p><img src="/images/C_3.png"></p>
<p>如果想增加数组元素，使用realloc调整结构体大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. #include&lt;stdlib.h&gt;</span><br><span class="line">4. typedef struct st_type</span><br><span class="line">5. &#123;</span><br><span class="line">6.  int i;</span><br><span class="line">7.  int a[0];//柔性数组成员</span><br><span class="line">8. &#125;type_a;</span><br><span class="line">9. </span><br><span class="line">10. int main()</span><br><span class="line">11. &#123;</span><br><span class="line">12.   //printf(&quot;sizeof(type_a) = %d\n&quot;, sizeof(type_a));</span><br><span class="line">13.   type_a* s = (type_a*)malloc(sizeof(type_a) + 10 * sizeof(int));//根据特点3，malloc申请的空间应该比结构体大小要大</span><br><span class="line">14.   if (s != NULL)</span><br><span class="line">15.   &#123;</span><br><span class="line">16.     s-&gt;i = 10;</span><br><span class="line">17.     int j = 0;</span><br><span class="line">18.     for (j = 0; j &lt; 10; j++)</span><br><span class="line">19.     &#123;</span><br><span class="line">20.       s-&gt;a[j] = j;</span><br><span class="line">21.     &#125;</span><br><span class="line">22.   &#125;</span><br><span class="line">23. </span><br><span class="line">24.   type_a* ptr = (type_a*)realloc(s,sizeof(type_a) + 20 * sizeof(int));//使用realloc重新调整结构体大小</span><br><span class="line">25.   if (ptr != NULL)</span><br><span class="line">26.   &#123;</span><br><span class="line">27.     s = ptr;</span><br><span class="line">28.   &#125;</span><br><span class="line">29. </span><br><span class="line">30.   //使用</span><br><span class="line">31. </span><br><span class="line">32.   //释放</span><br><span class="line">33.   free(s);</span><br><span class="line">34.   s = NULL;</span><br><span class="line">35. </span><br><span class="line">36.   return 0;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br></pre></td></tr></table></figure>

<h2 id="柔性数组的优势"><a href="#柔性数组的优势" class="headerlink" title="柔性数组的优势"></a>柔性数组的优势</h2><p>（1）把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以。</p>
<p>（2）连续的内存有益于提高访问速度，也有益于减少内存碎片。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>汇编调试</title>
    <url>/2023/02/27/GDB/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ol>
<li>打印寄存器的值:  <blockquote>
<p>i register</p>
</blockquote>
</li>
<li>打印所有寄存器的值:<blockquote>
<p>i all-registers</p>
</blockquote>
</li>
<li>打印单个寄存器的值<blockquote>
<p>i registers regname 或<br>p $regname”</p>
</blockquote>
</li>
<li>修改寄存器的值<blockquote>
<p><strong>例子</strong></p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;       </span><br><span class="line">        int a =0;               </span><br><span class="line"></span><br><span class="line">        a++;    </span><br><span class="line">        a++;    </span><br><span class="line">        printf(&quot;%d\n&quot;, a);      </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   PC寄存器会存储程序下一条要执行的指令，通过修改这个寄存器的值，可以达到改变程序执行流程的目的。上面的程序会输出“a&#x3D;2”，下面介绍一下如何通过修改PC寄存器的值，改变程序执行流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4               int a =0;</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x08050921 &lt;main+0&gt;:    push   %ebp</span><br><span class="line">0x08050922 &lt;main+1&gt;:    mov    %esp,%ebp</span><br><span class="line">0x08050924 &lt;main+3&gt;:    sub    $0x8,%esp</span><br><span class="line">0x08050927 &lt;main+6&gt;:    and    $0xfffffff0,%esp</span><br><span class="line">0x0805092a &lt;main+9&gt;:    mov    $0x0,%eax</span><br><span class="line">0x0805092f &lt;main+14&gt;:   add    $0xf,%eax</span><br><span class="line">0x08050932 &lt;main+17&gt;:   add    $0xf,%eax</span><br><span class="line">0x08050935 &lt;main+20&gt;:   shr    $0x4,%eax</span><br><span class="line">0x08050938 &lt;main+23&gt;:   shl    $0x4,%eax</span><br><span class="line">0x0805093b &lt;main+26&gt;:   sub    %eax,%esp</span><br><span class="line">0x0805093d &lt;main+28&gt;:   movl   $0x0,-0x4(%ebp)</span><br><span class="line">0x08050944 &lt;main+35&gt;:   lea    -0x4(%ebp),%eax</span><br><span class="line">0x08050947 &lt;main+38&gt;:   incl   (%eax)</span><br><span class="line">0x08050949 &lt;main+40&gt;:   lea    -0x4(%ebp),%eax</span><br><span class="line">0x0805094c &lt;main+43&gt;:   incl   (%eax)</span><br><span class="line">0x0805094e &lt;main+45&gt;:   sub    $0x8,%esp</span><br><span class="line">0x08050951 &lt;main+48&gt;:   pushl  -0x4(%ebp)</span><br><span class="line">0x08050954 &lt;main+51&gt;:   push   $0x80509b4</span><br><span class="line">0x08050959 &lt;main+56&gt;:   call   0x80507cc &lt;printf@plt&gt;</span><br><span class="line">0x0805095e &lt;main+61&gt;:   add    $0x10,%esp</span><br><span class="line">0x08050961 &lt;main+64&gt;:   mov    $0x0,%eax</span><br><span class="line">0x08050966 &lt;main+69&gt;:   leave</span><br><span class="line">0x08050967 &lt;main+70&gt;:   ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) info line 6</span><br><span class="line">Line 6 of &quot;a.c&quot; starts at address 0x8050944 &lt;main+35&gt; and ends at 0x8050949 &lt;main+40&gt;.</span><br><span class="line">(gdb) info line 7</span><br><span class="line">Line 7 of &quot;a.c&quot; starts at address 0x8050949 &lt;main+40&gt; and ends at 0x805094e &lt;main+45&gt;.</span><br></pre></td></tr></table></figure>

<p>通过“info line 6”和“info line 7”命令可以知道两条“a++;”语句的汇编指令起始地址分别是0x8050944和0x8050949。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">6               a++;</span><br><span class="line">(gdb) p $pc</span><br><span class="line">$3 = (void (*)()) 0x8050944 &lt;main+35&gt;</span><br><span class="line">(gdb) set var $pc=0x08050949</span><br></pre></td></tr></table></figure>

<p>当程序要执行第一条“a++;”语句时，打印pc寄存器的值，看到pc寄存器的值为0x8050944，与“info line 6”命令得到的一致。接下来，把pc寄存器的值改为0x8050949，也就是通过“info line 7”命令得到的第二条“a++;”语句的起始地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">8               printf(&quot;a=%d\n&quot;, a);</span><br><span class="line">(gdb)</span><br><span class="line">a=1</span><br><span class="line">9               return 0;</span><br></pre></td></tr></table></figure>

<p>接下来执行，可以看到程序输出“a&#x3D;1”，也就是跳过了第一条“a++;”语句。</p>
]]></content>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/2023/02/24/Shortcuts/vscode/</url>
    <content><![CDATA[<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><ol>
<li>Ctrl + D 或 Ctrl + Shift + L<br>选中所有相同选项, 一起修改</li>
</ol>
]]></content>
      <categories>
        <category>Shortcuts</category>
      </categories>
  </entry>
  <entry>
    <title>删除线语法</title>
    <url>/2023/02/12/Markdown/%E5%88%A0%E9%99%A4%E7%BA%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="删除线语法"><a href="#删除线语法" class="headerlink" title="删除线语法"></a>删除线语法</h1><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来<del>像这样</del>。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号<code>~~</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<p><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>任务列表语法</title>
    <url>/2023/02/12/Markdown/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="任务列表语法"><a href="#任务列表语法" class="headerlink" title="任务列表语法"></a>任务列表语法</h1><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<ul>
<li><input checked disabled type="checkbox"> Write the press release</li>
<li><input disabled type="checkbox"> Update the website</li>
<li><input disabled type="checkbox"> Contact the media</li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>定义列表</title>
    <url>/2023/02/12/Markdown/%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h1><p><strong>vs code 无效</strong></p>
<p>一些Markdown处理器允许您创建术语及其对应定义的_定义列表_。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure>

<p>HTML看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;First Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;Second Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt;</span><br><span class="line">  &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<dl><dt>First Term</dt><dd>This is the definition of the first term.</dd></dl><dl><dt>Second Term<br>: This is one definition of the second term.</dt><dd>This is another definition of the second term.</dd></dl>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>初始化Git仓库</title>
    <url>/2023/02/12/Git/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h1><p>$ cd &#x2F;home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo&#x2F;<br>$ cd gitrepo</p>
<p>$ git init –bare runoob.git<br>Initialized empty Git repository in &#x2F;home&#x2F;gitrepo&#x2F;runoob.git&#x2F;</p>
<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<p>$ chown -R git:git runoob.git</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>分割线语法</title>
    <url>/2023/02/12/Markdown/%E5%88%86%E5%89%B2%E7%BA%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown分割线语法"><a href="#Markdown分割线语法" class="headerlink" title="Markdown分割线语法"></a>Markdown分割线语法</h1><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure>

<p>以上三个分隔线的渲染效果看起来都一样：</p>
<ul>
<li></li>
</ul>
<h3 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="# 分隔线（Horizontal Rule）用法最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%88%86%E9%9A%94%E7%BA%BF%EF%BC%88horizontal-rule%EF%BC%89%E7%94%A8%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 分隔线（Horizontal Rule）用法最佳实践</h3><p>为了兼容性，请在分隔线的前后均添加空白行。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;Try to put a blank line before…</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="…and-after-a-horizontal-rule-Without-blank-lines-this-would-be-a-heading"><a href="#…and-after-a-horizontal-rule-Without-blank-lines-this-would-be-a-heading" class="headerlink" title="…and after a horizontal rule.|Without blank lines, this would be a heading.  "></a>…and after a horizontal rule.<code>|</code>Without blank lines, this would be a heading.  </h2><p>Don’t do this!&#96; |</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2023/02/12/Markdown/%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-使用"><a href="#Markdown-使用" class="headerlink" title="Markdown 使用"></a>Markdown 使用</h1><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h3 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="# 多个段落的块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%A4%9A%E4%B8%AA%E6%AE%B5%E8%90%BD%E7%9A%84%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
<h3 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="# 嵌套块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%B5%8C%E5%A5%97%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h3 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="# 带有其它元素的块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%B8%A6%E6%9C%89%E5%85%B6%E5%AE%83%E5%85%83%E7%B4%A0%E7%9A%84%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 带有其它元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; #### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>表格语法</title>
    <url>/2023/02/12/Markdown/%E8%A1%A8%E6%A0%BC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdwon表格语法"><a href="#Markdwon表格语法" class="headerlink" title="Markdwon表格语法"></a>Markdwon表格语法</h1><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
<p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure>

<p><strong>Tip:</strong> 使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="# 对齐"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%AF%B9%E9%BD%90">#</a> 对齐</h2><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
<th>Test Text</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
<td>Here’s this</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
<td>And more</td>
</tr>
</tbody></table>
<h2 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="# 格式化表格中的文字"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97">#</a> 格式化表格中的文字</h2><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（<code>`</code>）中的单词或短语，而不是代码块）和强调。</p>
<p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p>
<h2 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="# 在表中转义管道字符"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BD%AC%E4%B9%89%E7%AE%A1%E9%81%93%E5%AD%97%E7%AC%A6">#</a> 在表中转义管道字符</h2><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>转义字符语法</title>
    <url>/2023/02/12/Markdown/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-转义字符语法"><a href="#Markdown-转义字符语法" class="headerlink" title="Markdown 转义字符语法"></a>Markdown 转义字符语法</h1><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p>* Without the backslash, this would be a bullet in an unordered list.</p>
<h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="# 可做转义的字符"></a><a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#%E5%8F%AF%E5%81%9A%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6">#</a> 可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>backslash</td>
</tr>
<tr>
<td>`</td>
<td>backtick (see also <a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#escaping-backticks">escaping backticks in code</a>)</td>
</tr>
<tr>
<td>*</td>
<td>asterisk</td>
</tr>
<tr>
<td>_</td>
<td>underscore</td>
</tr>
<tr>
<td>{ }</td>
<td>curly braces</td>
</tr>
<tr>
<td>[ ]</td>
<td>brackets</td>
</tr>
<tr>
<td>( )</td>
<td>parentheses</td>
</tr>
<tr>
<td>#</td>
<td>pound sign</td>
</tr>
<tr>
<td>+</td>
<td>plus sign</td>
</tr>
<tr>
<td>-</td>
<td>minus sign (hyphen)</td>
</tr>
<tr>
<td>.</td>
<td>dot</td>
</tr>
<tr>
<td>!</td>
<td>exclamation mark</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="# 特殊字符自动转义"></a><a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89">#</a> 特殊字符自动转义</h2><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T</code>」 ，还得转换网址内的 <code>&amp;</code> 符号，如果你要链接到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;q=larry+bird</span><br></pre></td></tr></table></figure>

<p>你必须要把网址转成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;amp;q=larry+bird</span><br></pre></td></tr></table></figure>

<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
<p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 <code>&amp;</code> 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 <code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;copy;</span><br></pre></td></tr></table></figure>

<p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;T</span><br></pre></td></tr></table></figure>

<p>Markdown 就会将它转为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;amp;T</span><br></pre></td></tr></table></figure>

<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="https://markdown.com.cn/basic-syntax/#%E5%86%85%E8%81%94-html">行内 HTML</a> ，如果你使用 <code>&lt;</code> 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &lt; 5</span><br></pre></td></tr></table></figure>

<p>Markdown 将会把它转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &amp;lt; 5</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体。）</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>强调语法</title>
    <url>/2023/02/12/Markdown/%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown强调语法"><a href="#Markdown强调语法" class="headerlink" title="Markdown强调语法"></a>Markdown强调语法</h1><p>通过将文本设置为粗体或斜体来强调其重要性。</p>
<h2 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="# 粗体（Bold）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89">#</a> 粗体（Bold）</h2><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>I just love **bold text**.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>I just love __bold text__.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>Love**is**bold</code></td>
<td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td>
<td>Love<strong>is</strong>bold</td>
</tr>
</tbody></table>
<h3 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="# 粗体（Bold）用法最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E7%94%A8%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 粗体（Bold）用法最佳实践</h3><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>Love**is**bold</code></td>
<td><code>Love__is__bold</code></td>
</tr>
</tbody></table>
<h2 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="# 斜体（Italic）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89">#</a> 斜体（Italic）</h2><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>Italicized text is the *cat&#39;s meow*.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>Italicized text is the _cat&#39;s meow_.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>A*cat*meow</code></td>
<td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td>
<td>A_cat_meow</td>
</tr>
</tbody></table>
<h3 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="# 斜体（Italic）用法的最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89%E7%94%A8%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 斜体（Italic）用法的最佳实践</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>A*cat*meow</code></td>
<td><code>A_cat_meow</code></td>
</tr>
</tbody></table>
<h2 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="# 粗体（Bold）和斜体（Italic）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E5%92%8C%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89">#</a> 粗体（Bold）和斜体（Italic）</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>This text is ***really important***.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is ___really important___.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is __*really important*__.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is **_really important_**.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td>
<td>This is really**<em>very</em>**important text.</td>
</tr>
</tbody></table>
<h3 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="# 粗体（Bold）和斜体（Italic）用法的最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E5%92%8C%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89%E7%94%A8%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 粗体（Bold）和斜体（Italic）用法的最佳实践</h3><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really___very___important text.</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>语法速查表</title>
    <url>/2023/02/12/Markdown/%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Markdown-语法速查表-Markdown-官方教程"><a href="#Markdown-语法速查表-Markdown-官方教程" class="headerlink" title="Markdown 语法速查表 | Markdown 官方教程"></a>Markdown 语法速查表 | Markdown 官方教程</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>Markdown 速查表提供了所有 Markdown 语法元素的基本解释。如果你想了解某些语法元素的更多信息，请参阅更详细的 基本语法 和 扩展语法.</p>
</blockquote>
<hr>
<h2 id="总览"><a href="#总览" class="headerlink" title="# 总览"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E6%80%BB%E8%A7%88">#</a> 总览</h2><p>Markdown 速查表提供了所有 Markdown 语法元素的基本解释。如果你想了解某些语法元素的更多信息，请参阅更详细的 <a href="https://markdown.com.cn/basic-syntax">基本语法</a> 和 <a href="https://markdown.com.cn/extended-syntax">扩展语法</a>.</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="# 基本语法"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">#</a> 基本语法</h2><p>这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>Markdown 语法</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://markdown.com.cn/basic-syntax/headings.html">标题（Heading）</a></td>
<td><code># H1   ## H2   ### H3</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/bold.html">粗体（Bold）</a></td>
<td><code>**bold text**</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/italic.html">斜体（Italic）</a></td>
<td><code>*italicized text*</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/blockquotes.html">引用块（Blockquote）</a></td>
<td><code>&gt; blockquote</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/ordered-lists.html">有序列表（Ordered List）</a></td>
<td><code>1. First item</code></td>
</tr>
<tr>
<td></td>
<td><code>2. Second item</code></td>
</tr>
<tr>
<td></td>
<td><code>3. Third item</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/unordered-lists.html">无序列表（Unordered List）</a></td>
<td><code>- First item   - Second item   - Third item   </code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/code.html">代码（Code）</a></td>
<td><code>`code`</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html">分隔线（Horizontal Rule）</a></td>
<td><code>---</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/links.html">链接（Link）</a></td>
<td><code>[title](https://www.example.com)</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/images.html">图片（Image）</a></td>
<td><code>![alt text](image.jpg)</code></td>
</tr>
</tbody></table>
<h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="# 扩展语法"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">#</a> 扩展语法</h2><p>这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>Markdown 语法</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://markdown.com.cn/extended-syntax/tables.html">表格（Table）</a></td>
<td>&#96;</td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/fenced-code-blocks.html">代码块（Fenced Code Block）</a></td>
<td><code>```   &#123;     &quot;firstName&quot;: &quot;John&quot;,     &quot;lastName&quot;: &quot;Smith&quot;,     &quot;age&quot;: 25   &#125;   ```</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/footnotes.html">脚注（Footnote）</a></td>
<td>Here’s a sentence with a footnote. <code>[^1]</code></td>
</tr>
<tr>
<td><code>[^1]</code>: This is the footnote.</td>
<td></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/heading-ids.html">标题编号（Heading ID）</a></td>
<td><code>### My Great Heading &#123;#custom-id&#125;</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/definition-lists.html">定义列表（Definition List）</a></td>
<td><code>term   : definition</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/strikethrough.html">删除线（Strikethrough）</a></td>
<td><code>~~The world is flat.~~</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/task-lists.html">任务列表（Task List）</a></td>
<td><code>- [x] Write the press release   - [ ] Update the website   - [ ] Contact the media</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
</search>
