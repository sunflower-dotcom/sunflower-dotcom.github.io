<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/03/19/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="任务列表语法"><a href="#任务列表语法" class="headerlink" title="任务列表语法"></a>任务列表语法</h1><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<ul>
<li><input checked disabled type="checkbox"> Write the press release</li>
<li><input disabled type="checkbox"> Update the website</li>
<li><input disabled type="checkbox"> Contact the media</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Epoll</title>
    <url>/2023/03/19/C/Epoll/</url>
    <content><![CDATA[<h1 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h1><p>**<code>epoll</code>**是<a href="https://zh.wikipedia.org/wiki/Linux" title="Linux">Linux</a>内核的可扩展I&#x2F;O事件通知机制<sup id="cite_ref-1" class="reference"><a href="https://zh.wikipedia.org/wiki/Epoll#cite_note-1">[1]</a></sup>。于Linux 2.5.44首度登场，它设计目的旨在取代既有<a href="https://zh.wikipedia.org/wiki/POSIX" title="POSIX">POSIX</a> <a href="https://zh.wikipedia.org/wiki/Select_(Unix)" title="Select (Unix)"><code>select(2)</code></a>与<code>poll(2)</code><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" title="系统调用">系统函数</a>，让需要大量操作<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E6%8F%8F%E8%BF%B0%E5%AD%90" title="文件描述符">文件描述符</a>的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，<code>epoll</code>的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件</p>
<h2 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h2><p>int epoll_create(int size);</p>
<p>在内核中创建<code>epoll</code>实例并返回一个<code>epoll</code>文件描述符。 在最初的实现中，调用者通过 <code>size</code> 参数告知内核需要监听的文件描述符数量。如果监听的文件描述符数量超过 size, 则内核会自动扩容。而现在 size 已经没有这种语义了，但是调用者调用时 size 依然必须大于 0，以保证后向兼容性。</p>
<p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>向 epfd 对应的内核<code>epoll</code> 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 <code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_MOD</code>, <code>EPOLL_CTL_DEL</code> 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 <code>EPOLLET</code> flag，那么监听该事件的方式是边缘触发。</p>
<p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p>
<p>当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</p>
<h2 id="触发模式-编辑"><a href="#触发模式-编辑" class="headerlink" title="触发模式[编辑]"></a>触发模式[<a href="https://zh.wikipedia.org/w/index.php?title=Epoll&action=edit&section=2" title="编辑章节：触发模式">编辑</a>]</h2><p><code>epoll</code>提供<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%AD#%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91" title="中断">边沿触发</a>及<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%AD#%E7%8A%B6%E6%80%81%E8%A7%A6%E5%8F%91" title="中断">状态触发</a>模式。在边沿触发模式中，<code>epoll_wait</code>仅会在新的事件首次被加入<code>epoll</code>队列时返回；于level-triggered模式下，<code>epoll_wait</code>在事件状态未变更前将不断被触发。状态触发模式是默认的模式。</p>
<p>状态触发模式与边沿触发模式有读和写两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到<code>epoll</code>实例上，<code>epoll</code>实例会通过<code>epoll_wait</code>返回值的形式通知我们哪些读事件已经就绪。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则每次调用 <code>epoll_wait</code> 时返回的事件列表都会包含该事件。直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，读事件就绪后只会通知一次，不会反复通知。</p>
<p>然后我们再考虑写的情况。水平触发模式下，只要文件描述符对应的内核写缓冲器未满，就会一直通知可写事件。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会通知一次可写事件。</p>
<p>举例来说，倘若有一个已经于<code>epoll</code>注册之<a href="https://zh.wikipedia.org/wiki/Anonymous_pipe" title="Anonymous pipe">流水线</a>接获资料，<code>epoll_wait</code>将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered模式下，任何对<code>epoll_wait</code>之调用都将即刻返回，直到缓冲器中的资料全部被读取；然而，在edge-triggered的情境下，<code>epoll_wait</code>仅会于再次接收到新资料(亦即，新资料被写入流水线)时返回。</p>
<h3 id="边沿触发模式-编辑"><a href="#边沿触发模式-编辑" class="headerlink" title="边沿触发模式[编辑]"></a>边沿触发模式[<a href="https://zh.wikipedia.org/w/index.php?title=Epoll&action=edit&section=3" title="编辑章节：边沿触发模式">编辑</a>]</h3><p>边沿触发模式使得程序有可能在用户态缓存 IO 状态。nginx 使用的是边沿触发模式。</p>
<p>文件描述符有两种情况是推荐使用边沿触发模式的。</p>
<ol>
<li>read 或者 write 系统调用返回了 EAGAIN。</li>
<li>非阻塞的文件描述符。</li>
</ol>
<p>可能的缺陷：</p>
<ol>
<li>如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致饥饿。举个例子，假设你在监听一个文件描述符列表，而某个文件描述符上有大量的输入（不间断的输入流），那么你在读完它的过程中就没空处理其他就绪的文件描述符。（因为边沿触发模式只会通知一次可读事件，所以你往往会想一次把它读完。）一种解决方案是，程序维护一个就绪队列，当 <code>epoll</code> 实例通知某文件描述符就绪时将它在就绪队列数据结构中标记为就绪，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。</li>
<li>如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 <code>epoll</code> 实例并不知道这件事，需要你从 <code>epoll</code> 删除掉。</li>
</ol>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/02/C/%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p><strong><a href="http://lib.csdn.net/base/c" title="C语言知识库">C语言</a>运算符优先级</strong></p>
<table border="1" cellspacing="0" cellpadding="0" width="612"><tbody><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>优先级</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>运算符</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>名称或含义</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>使用形式</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>结合方向</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>说明</strong></p></td></tr><tr><td rowspan="4"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>1</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">[]</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">数组下标</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">数组名[常量表达式]</p></td><td rowspan="4"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">()</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">圆括号</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">(表达式）/函数名(形参表)</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">.</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">成员选择（对象）</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">对象.成员名</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">-&gt;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">成员选择（指针）</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">对象指针-&gt;成员名</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td rowspan="9"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>2</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">-</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">负号运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">-表达式</p></td><td rowspan="9"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:red">右到左</span></strong></p></td><td rowspan="7"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">单目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">~</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位取反运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">~表达式</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">++</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">自增运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">++变量名/变量名++</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">--</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">自减运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--变量名/变量名--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">*</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">取值运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">*指针变量</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&amp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">取地址运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&amp;变量名</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">!</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">逻辑非运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">!表达式</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">(</span><span style="color:blue">类型</span><span style="color:blue">)</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">强制类型转换</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">(数据类型)表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">sizeof</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">长度运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">sizeof(表达式)</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td rowspan="3"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>3</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">/</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">除</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式/表达式</p></td><td rowspan="3"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td rowspan="3"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">*</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">乘</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式*表达式</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">%</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">余数（取模）</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">整型表达式%整型表达式</p></td></tr><tr><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>4</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">+</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">加</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式+表达式</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">-</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">减</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式-表达式</p></td></tr><tr><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>5</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&lt;&lt;&nbsp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左移</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量&lt;&lt;表达式</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&gt;&gt;&nbsp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">右移</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量&gt;&gt;表达式</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td rowspan="4"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>6</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&gt;&nbsp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">大于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&gt;表达式</p></td><td rowspan="4"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td rowspan="4"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&gt;=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">大于等于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&gt;=表达式</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&lt;&nbsp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">小于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&lt;表达式</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&lt;=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">小于等于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&lt;=表达式</p></td></tr><tr><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>7</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">==</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">等于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式==表达式</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td rowspan="2"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">！</span><span style="color:blue">=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">不等于</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式!= 表达式</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>8</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&amp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位与</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&amp;表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>9</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">^</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位异或</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式^表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>10</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">|</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位或</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式|表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>11</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&amp;&amp;</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">逻辑与</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式&amp;&amp;表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>12</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">||</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">逻辑或</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式||表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">双目运算符</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>13</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">?:</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">条件运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式1?</p><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式2: 表达式3</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:red">右到左</span></strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:red">三目运算符</span></p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><span style="color:red">&nbsp;</span></p></td></tr><tr><td rowspan="11"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>14</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">赋值运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量=表达式</p></td><td rowspan="11"><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:red">右到左</span></strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">/=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">除后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量/=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">*=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">乘后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量*=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">%=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">取模后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量%=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">+=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">加后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量+=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">-=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">减后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量-=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&lt;&lt;=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左移后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量&lt;&lt;=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&gt;&gt;=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">右移后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量&gt;&gt;=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">&amp;=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位与后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量&amp;=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">^=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位异或后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量^=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">|=</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">按位或后赋值</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">变量|=表达式</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr><tr><td width="612" colspan="6"><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">&nbsp;</p></td></tr><tr><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong>15</strong></p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"><strong><span style="color:blue">，</span></strong></p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">逗号运算符</p></td><td><p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">表达式,表达式,…</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">左到右</p></td><td><p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">--</p></td></tr></tbody></table>

<p><strong>说明：</strong></p>
<p> <strong>同一优先级的运算符，运算次序由结合方向所决定。<br> 简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</strong></p>
]]></content>
  </entry>
  <entry>
    <title>对话记录</title>
    <url>/2023/03/21/ChatGpt/Questions/</url>
    <content><![CDATA[<h1 id="对话记录"><a href="#对话记录" class="headerlink" title="对话记录"></a>对话记录</h1><p>1. </p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question :"></a>Question :</h2><p>the bignum  generated by bn_bin2bn needs to be free&gt;</p>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer :"></a>Answer :</h2><p>As an AI language model, I don’t have enough context to understand what you’re referring to. Can you please provide more information or context so I can better assist you?</p>
<p>2. </p>
<h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question :"></a>Question :</h2><p>the bignum  generated by bn_bin2bn needs to be free?</p>
<h2 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer :"></a>Answer :</h2><p>As a language model, I can infer that you might be referring to the OpenSSL library function <code>bn_bin2bn()</code>, which converts an array of bytes to a BIGNUM (big integer) structure. If that’s the case, then yes, you would need to free the BIGNUM object returned by <code>bn_bin2bn()</code> after you’re done using it to avoid memory leaks. You can do this by calling the <code>BN_free()</code> function on the BIGNUM object.</p>
<p>3. </p>
<h2 id="Question-2"><a href="#Question-2" class="headerlink" title="Question :"></a>Question :</h2><p>how to use bn_bin2bn?</p>
<h2 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer :"></a>Answer :</h2><p>bn_bin2bn()  is a function provided by the OpenSSL library that converts an array of bytes to a BIGNUM (big integer) structure. Here’s an example of how you can use it:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The byte array you want to convert to a BIGNUM</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bytes[] = &#123;<span class="number">0x02</span>, <span class="number">0x4A</span>, <span class="number">0xFC</span>, <span class="number">0x1A</span>, <span class="number">0x6F</span>&#125;;</span><br><span class="line">    <span class="type">int</span> numBytes = <span class="keyword">sizeof</span>(bytes) / <span class="keyword">sizeof</span>(bytes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new BIGNUM object and convert the byte array to it</span></span><br><span class="line">    BIGNUM *bn = BN_bin2bn(bytes, numBytes, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bn) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something with the BIGNUM...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the BIGNUM object to avoid memory leaks</span></span><br><span class="line">    BN_free(bn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The  BN_bin2bn()  function takes three parameters: </p>
<ol>
<li>const unsigned char *s : A pointer to the byte array you want to convert to a BIGNUM. </li>
<li>int len : The length of the byte array. </li>
<li>BIGNUM *ret : A pointer to a BIGNUM object that will hold the converted value.</li>
</ol>
<p>If everything goes well,  BN_bin2bn()  returns a pointer to the BIGNUM object that holds the converted value. Don’t forget to free the BIGNUM object when you’re done with it, using the  BN_free()  function.<br>Question :</p>
<p>the third parameter of bn_bin2bn is same to the return value of that function?<br>Answer :</p>
<p>Share icon<br>Yes, the third parameter ( BIGNUM *ret ) of the  BN_bin2bn()  function is used to pass a pointer to a BIGNUM object in which the converted big integer will be stored. If the conversion is successful, the function returns the same pointer as the third parameter, which points to the BIGNUM object.  </p>
<p>Here is an example of how you can use  BN_bin2bn()  and its return value:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bin[] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(bin);</span><br><span class="line">    BIGNUM *bn = <span class="literal">NULL</span>;</span><br><span class="line">    bn = BN_bin2bn(bin, len, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something with bn</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory used by bn</span></span><br><span class="line">    BN_free(bn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example,  BN_bin2bn()  is used to convert the  bin  byte array into a BIGNUM. The  NULL  as the third parameter tells the function to create a new BIGNUM object to store the converted big integer. If the conversion is successful,  bn  will hold the pointer to the new BIGNUM object. After using  bn , you should free its memory by calling  BN_free(bn) .<br>Question :</p>
<p>how to use DH_new?<br>Answer :</p>
<p>Share icon<br>DH_new()  is a function provided by the OpenSSL library that creates a new  DH  (Diffie-Hellman) key exchange. Here is an example of how to use  DH_new() :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/dh.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a new DH object</span></span><br><span class="line">    DH *dh = DH_new();</span><br><span class="line">    <span class="keyword">if</span> (!dh) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Do something with the DH object...</span></span><br><span class="line">     <span class="comment">// Free the DH object to avoid memory leaks</span></span><br><span class="line">    DH_free(dh);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The  DH_new()  function creates a new  DH  object and initializes it with default values. If the function returns  NULL , it means that an error occurred and you should handle it appropriately. Once you’re finished with the  DH  object, you should free it by calling  DH_free(dh)  to avoid memory leaks.</p>
<p>4. </p>
<h2 id="Question-3"><a href="#Question-3" class="headerlink" title="Question :"></a>Question :</h2><p>how to user “for” in shell?</p>
<h2 id="Answer-3"><a href="#Answer-3" class="headerlink" title="Answer :"></a>Answer :</h2><p>In shell scripting, a  for  loop is used for repeating a set of commands for a specified number of times. The syntax of the  for  loop in shell is as follows:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable in list</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>Here,  variable  represents a variable that will take on the value of each item in the  list , and  command1 ,  command2 , and so on represent the commands that will be executed for each item in the  list . </p>
<p>Here is an example of using a  for  loop in shell:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Define a list of files</span></span><br><span class="line">files=(&quot;file1.txt&quot; &quot;file2.txt&quot; &quot;file3.txt&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Loop through each file <span class="keyword">in</span> the list</span></span><br><span class="line">for file in &quot;$&#123;files[@]&#125;&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;Processing file: $file&quot;</span><br><span class="line">    # Add your commands to process the file here</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>This example shows how to loop over a list of files and perform some action on each file. You can modify this example to use your own list of items and commands.</p>
<p>5. </p>
<h2 id="Question-4"><a href="#Question-4" class="headerlink" title="Question :"></a>Question :</h2><p>in shell, how to loop n times?</p>
<h2 id="Answer-4"><a href="#Answer-4" class="headerlink" title="Answer :"></a>Answer :</h2><p>In shell scripting, you can loop a specified number of times using a  for  loop with a numeric sequence. Here’s an example of how to loop  n  times in shell:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">Set the number of loops you want to perform</span></span><br><span class="line">n=10</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">Loop n <span class="built_in">times</span></span></span><br><span class="line">for i in $(seq 1 $n)</span><br><span class="line">do</span><br><span class="line">    echo &quot;This is loop number $i&quot;</span><br><span class="line">    # Add your commands to be executed here</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>In this example, we’ve set the value of  n  to 10, so the loop will execute 10 times. We use the  seq  command to generate a sequence of numbers from 1 to  n  and use this sequence in the  for  loop. You can replace  echo “This is loop number $i”  with any commands you want to execute in each iteration of the loop.</p>
<p>6. </p>
<h2 id="Question-5"><a href="#Question-5" class="headerlink" title="Question :"></a>Question :</h2><p>how to show file context when it is changing in linux shell?</p>
<h2 id="Answer-5"><a href="#Answer-5" class="headerlink" title="Answer :"></a>Answer :</h2><p>In Linux shell, you can use the  tail  command with the  -f  option to view the contents of a file as it changes in real-time. Here’s an example:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f /path/to/file.log</span><br></pre></td></tr></table></figure>
<p>This command will display the last 10 lines of the file specified by  &#x2F;path&#x2F;to&#x2F;file.log  and then keep the file open and display any new content that is appended to the end of the file. As new lines are added to the file, they will be displayed in the terminal.<br>You can use  Ctrl + C  to stop the  tail  command and return to the command prompt.</p>
<p>7. </p>
<h2 id="Question-6"><a href="#Question-6" class="headerlink" title="Question :"></a>Question :</h2><p>why DH_compute_key error with stack like SLL_next failed?</p>
<h2 id="Answer-6"><a href="#Answer-6" class="headerlink" title="Answer :"></a>Answer :</h2><p>The error “SLL_next failed” usually occurs when there is an issue with the OpenSSL library’s linked list data structure. This error can occur for several reasons, but most commonly it happens when there is a memory corruption or invalid pointer. </p>
<p>When using <code>DH_compute_key()</code> function in OpenSSL to compute a shared secret key using Diffie-Hellman key exchange, make sure that you have properly initialized the DH object before calling this function. Also, check that both parties have the same DH parameters (p, g, and possibly q) and that their public keys have been exchanged correctly. </p>
<p>If you continue to encounter the “SLL_next failed” error, you may need to debug your code and look for any memory corruption or invalid pointer issues. You can use memory profiling tools like Valgrind to help in this process or consider reviewing and improving your code.</p>
<p>8. </p>
<h2 id="Question-7"><a href="#Question-7" class="headerlink" title="Question"></a>Question</h2><p>how to find the version of a lib?</p>
<h2 id="Answer-7"><a href="#Answer-7" class="headerlink" title="Answer :"></a>Answer :</h2><p>To find the version of a library in Linux or Unix-based systems, you can use the  ldd  command followed by the path to the library file. Here is the syntax for the command:<br>ldd &#x2F;path&#x2F;to&#x2F;library<br>When you run this command, it will display the libraries that the specified library depends on, along with their paths. The version of each library should be listed next to the library name.  </p>
<p>Alternatively, you can also use the  strings  command to search for the version string in the library. Here is the syntax for the command:<br>strings &#x2F;path&#x2F;to&#x2F;library | grep LIBRARY_NAME<br>Replace  LIBRARY_NAME  with the name of the library you want to find the version string for. This command will search for all occurrences of the specified library name in the library file and display any version strings that it finds.</p>
<p>9. </p>
<h2 id="Question-8"><a href="#Question-8" class="headerlink" title="Question :"></a>Question :</h2><p>how to use DH_generate_key?</p>
<h2 id="Answer-8"><a href="#Answer-8" class="headerlink" title="Answer :"></a>Answer :</h2><p>DH_generate_key()  is a function provided by the OpenSSL library that generates a new Diffie-Hellman key pair. Here is an example of how to use  DH_generate_key()  with  DH_new() :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/dh.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a new DH object</span></span><br><span class="line">    DH *dh = DH_new();</span><br><span class="line">    <span class="keyword">if</span> (!dh) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Generate a new key pair</span></span><br><span class="line">    <span class="keyword">if</span> (DH_generate_key(dh) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// Do something with the DH object...</span></span><br><span class="line">     <span class="comment">// Free the DH object to avoid memory leaks</span></span><br><span class="line">    DH_free(dh);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example,  DH_new()  is used to create a new  DH  object.  DH_generate_key()  is then called to generate a new key pair for the  DH  object. If the function returns a value other than  1 , it means that an error occurred and you should handle it appropriately. Once you’re finished with the  DH  object, you should free it by calling  DH_free(dh)  to avoid memory leaks. </p>
<p>After the key pair is generated, you can access the private key using the  priv_key  member of the  DH  object and the public key using the  pub_key  member. For example: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BIGNUM *private_key = dh-&gt;priv_key; </span><br><span class="line">BIGNUM *public_key = dh-&gt;pub_key; </span><br></pre></td></tr></table></figure>
<p>You can then use these keys to perform a Diffie-Hellman key exchange to generate a shared secret key between two parties.</p>
]]></content>
      <categories>
        <category>ChatGPT</category>
      </categories>
  </entry>
  <entry>
    <title>位域</title>
    <url>/2023/02/12/C/%E4%BD%8D%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h1><h1 id="让人疑惑的C语言位域-知乎"><a href="#让人疑惑的C语言位域-知乎" class="headerlink" title="让人疑惑的C语言位域 - 知乎"></a>让人疑惑的C语言位域 - 知乎</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>在实际的应用中，有些数据的存储只需要几个二进制位，而不需要一个字节或几个字节，比如：电灯接通电源的状态，只有通电和未通电两种状态，用 1 和 0 就可以表示，为了满足这种需求，C 语言中引入了位域的概念 位…</p>
</blockquote>
<hr>
<p>在实际的应用中，有些数据的存储只需要几个二进制位，而不需要一个字节或几个字节，比如：电灯接通电源的状态，只有通电和未通电两种状态，用 1 和 0 就可以表示，为了满足这种需求，C 语言中引入了位域的概念</p>
<h3 id="位域是什么"><a href="#位域是什么" class="headerlink" title="位域是什么"></a>位域是什么</h3><p>位域是一种数据结构，可以把数据以二进制位的形式紧凑的存储，它允许程序对此结构的位进行操作</p>
<p>在计算机早期，内存是非常稀缺的，需要尽可能的节省每一个字节，所以，C 语言中就出现了能针对二进制位进行操作的位域</p>
<h3 id="为什么要用位域"><a href="#为什么要用位域" class="headerlink" title="为什么要用位域"></a>为什么要用位域</h3><p>位域这种数据结构，可以最大限度的节省存储空间，对于一些非常频繁的操作，需要尽可能的减少操作的数据，比如：在开发网络应用时，数据的序列化和反序列化是很频繁的，如果能减少数据的长度，对提升数据打包效率是很有帮助的</p>
<p>位域的出现，让我们可以用变量名代表某些bit，并通过变量名获取和设置 bit 的值，而不是通过晦涩难理解的位操作来进行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct field</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char b0 : 3,</span><br><span class="line">                  b1 : 2,</span><br><span class="line">                  b2 : 3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct field bf;</span><br><span class="line">bf.b1 = 3;</span><br></pre></td></tr></table></figure>

<p>通过位域设置中间 2 个bit 的值，只需要设置结构体中 <code>b1</code> 字段值即可，如果使不用位域字段，就需要进行位的 “或” 和 “与” 运算</p>
<h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>C 语言中，位域的表示形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct bitfield</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int b0 : n0,</span><br><span class="line">                 b1 : n1,</span><br><span class="line">                 b2 : n2,</span><br><span class="line">                 ...</span><br><span class="line">                 bn : nk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>b0、b1、b2 ... bn</code> 表示位域成员，<code>n0、n1、n2 ... nk</code> 表示成员占用多少个 bit</p>
<p>位域表示的范围通常不能超过其所依附类型所能表示的 bit 数，比如：上面 <code>bitfield</code> 结构体中 位域所依附的类型是 <code>unsigned int</code>, 最大能表示 32 个 bit，也就是说，<code>n0、n1、n2 ... nk</code> 总 bit 数不能超过 32，每个成员超过指定 bit 表示的最大数值时会被截断，具体请看下面的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct fields</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:7;</span><br><span class="line">        unsigned short b:5;</span><br><span class="line">        unsigned char c:4;</span><br><span class="line">        </span><br><span class="line">    &#125;fs;</span><br><span class="line"></span><br><span class="line">    fs.a = 0x8F;</span><br><span class="line">    fs.b = 0x1A;</span><br><span class="line">    fs.c = 0x19;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%#x, %#x, %#x \n&quot;,fs.a, fs.b, fs.c);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>gcc -g -o bitfield bitfield.c</code> 编译并运行，结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost]# ./bitfield                   </span><br><span class="line">0xf, 0x1a, 0x9</span><br></pre></td></tr></table></figure>

<p>字段 <code>a</code> 赋值为 <code>0x8F</code> 对应的二进制为 <strong>1000 1111</strong>，由于 <code>a</code> 只有 7 个bit，给它赋的值超出了限定的位数，超出部分被丢弃，保留低 7 位，最终结果为 <strong>000 1111</strong> ，换成十六进制是 <strong>0xf</strong></p>
<p>字段 <code>b</code> 赋值为 <code>0x1A</code> 对应的二进制为 <strong>1 1010</strong>， <code>b</code> 包含 5 个bit，取结果中的低 5 位，最终结果为 <strong>1 1010</strong> ，换成十六进制是 <strong>0x1a</strong> , 输出结果和赋值相同，即没有超出限定 bit 数</p>
<p>字段 <code>c</code> 赋值为 <code>0x19</code> 对应的二进制为 <strong>1</strong> <strong>1001</strong>，由于 <code>c</code> 只有 4 个bit，给它赋的值超出了限定的位数，超出部分被丢弃，保留低 4 位，最终结果为 <strong>1001</strong> ，换成十六进制是 <strong>0x9</strong></p>
<p>位域的使用有一定的限制，机器最小粒度的寻址单位是字节，我们无法像获得某一个字节的地址一样去获得某个 bit 的地址，下面是一个错误的示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct fields</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:7;</span><br><span class="line">        unsigned short b:5;</span><br><span class="line">        unsigned char c:4;</span><br><span class="line">    &#125;fs;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%p\n&quot;,&amp;fs.a);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码功能是打印出成员 <code>a</code> 的地址，它无法通过编译，错误如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitfield.c: 在函数‘main’中:</span><br><span class="line">bitfield.c:11:5: 错误：无法取得位段‘a’的地址</span><br><span class="line">     printf(&quot;%p\n&quot;,&amp;fs.a);</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure>

<h3 id="位域的存储"><a href="#位域的存储" class="headerlink" title="位域的存储"></a>位域的存储</h3><p>C 标准中只允许 <code>unsigned int</code>、<code>signed int</code>、<code>int</code> 类型的位域申明，后面又增加了 <code>bool</code> 类型的支持，一些编译器像 <code>gcc</code>、<code>msvc</code>等自行加入了一些扩展，使得其他的类型(<code>short、char</code>等)也支持位域</p>
<p>位域的存储跟编译器相关，不同的编译器，存储位域的方式可能不一样，总的来说可以分成下面几类</p>
<p><strong>1、相邻位域成员，它们的类型相同时</strong></p>
<p>如果它们的 bit 数之和小于等于所依附类型的 bit 数，那么，后面的成员紧接着前面的成员存储</p>
<p>如果它们的 bit 数之和大于所依附类型的 bit 数，那么超过的成员会存储到新的存储单元中，新存储单元会偏移成员所依附类型的 sizeof 字节数</p>
<p>以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned short b:4;</span><br><span class="line">        unsigned short c:2;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost]# ./bitfield                   </span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><code>a 、b、c</code> 字段都是 <code>unsigned short</code> 类型，它们的 bit 数之和为 <strong>10 + 4 + 2 &#x3D; 16</strong>, 刚好等于 <strong>unsigned short</strong> 的 bit 数，所以它们会紧凑的存储，没有任何空隙</p>
<p>如果把 <code>a</code> 的 bit 数改成 11，即 **unsigned short a:11;**，此时，<code>a</code> 和 <code>b</code> 的 bit 数之和为 <strong>11 + 4 &#x3D; 15</strong>，没有超过 <code>unsigned short</code> 的 bit 数</p>
<p>如果再加上 <code>c</code> 的 bit 数，结果变成了 <strong>17</strong>，超过了 <code>unsigned short</code> 的 bit 数，这种情况下，<code>a</code> 和 <code>b</code> 还是会紧凑的存储，而 <code>c</code> 会存储到新的存储单元中，新的存储单元字节数为 <code>sizeof(unsigned short) = 2</code>， 所以此时 <strong>sizeof(fg)</strong> 是 <strong>4</strong></p>
<p><strong>2、相邻位域成员，它们的类型不同时</strong></p>
<p>这种情况跟具体的编译器相关，以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned char b:4;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码分别用 gcc4.8.5 和 vs2013 进行编译运行，结果如下</p>
<p>gcc的结果</p>
<p><img src="https://pic1.zhimg.com/v2-d24b60824986660fedafe38d419a983c_b.png"></p>
<p>vs2013的结果</p>
<p><img src="https://pic4.zhimg.com/v2-bbd2e82b112cd1c50f3bf58278c4a41f_b.jpg"></p>
<p>可以看到，当相邻位域成员所依附的类型不同时，不同的编译器产生的结果是不一样的</p>
<p>在 gcc 下的运行结果是 2 ，表示 <code>a</code> 和 <code>b</code> 还是紧凑存储的</p>
<p>而在 vs2013 下运行的结果是 4，这说明 <code>a</code> 和 <code>b</code> 完全按照他们所依附的类型来存储，此时位域没有进行压缩存储</p>
<p><strong>3、位域成员之间存在非位域成员时</strong></p>
<p>这种情况 gcc 和 vs2013 都不会进行压缩存储，按照内存对齐的规则来存储</p>
<p>还是以下面的代码为例来说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct flag</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short a:10;</span><br><span class="line">        unsigned int i;</span><br><span class="line">        unsigned char b:4;</span><br><span class="line">    &#125;fg;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(fg));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码分别用 gcc4.8.5 和 vs2013 进行编译运行，结果如下</p>
<p>gcc的结果</p>
<p><img src="https://pic2.zhimg.com/v2-7cc4101dd6c9bfb9b5355545ab9ad28d_b.png"></p>
<p>vs2013的结果</p>
<p><img src="https://pic2.zhimg.com/v2-0232a27563e369319790c6cdc634cba5_b.jpg"></p>
<p>不管在 gcc 还是在 vs2013 下，结果都相同，为了提高访问效率，成员按照 4 字节对齐，所以 <code>sizeof(fg)</code> 结果是 12</p>
<p><strong>现在位域使用得也比较少了，大概有以下几个的原因</strong></p>
<p>1、早期计算机内存很稀缺，在内存的使用上需要精打细算，但是，现代的计算机内存容量有了很大的提升，一般不需要为了节省几个字节而使用内存更加紧凑的位域</p>
<p>2、通过前面的介绍，我们知道结构体中位域的存储是跟编译器相关，这就导致了它的可移植性比较差</p>
<h3 id="匿名位域"><a href="#匿名位域" class="headerlink" title="匿名位域"></a>匿名位域</h3><p>位域成员可以不指定名字，只给出成员的数据类型以及占用的 bit 数，称作匿名位域</p>
<p>匿名位域字段只是起填充 bit，调整成员位置的作用，并无实际的意义</p>
<p>因为没有指定成员名字，所以也不能使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">    unsigned short a:10,</span><br><span class="line">                    :6; //匿名位域,不能使用</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面例子中，如果没有匿名位域的话，<code>sizeof(fields)</code> 的结果为 <strong>2</strong>，加入 <strong>6</strong> 个 bit 的填充以后，<code>a</code> 和 <code>b</code> 将分开存储， <code>sizeof(fields)</code> 的结果变成了 <strong>4</strong></p>
<p>我们还可以通过匿名0长度的位域字段来强制位域存储到下一个存储单元中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short a:10;</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的结构体本来可以全部存储到一个 <strong>2</strong> 字节的存储单元中，如果我们想让 <code>a</code> 和 <code>b</code> 存储到不同的存储单元中，可以在结构体中加入一个匿名的 0 长度的位域字段来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fields</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short a:10;</span><br><span class="line">    unsigned short  :0;</span><br><span class="line">    unsigned short b:3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样申明后，<code>sizeof(struct fields)</code> 就变成 <strong>4</strong> 了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文讲述了位域的基础，使用以及存储，其中位域的存储跟具体的编译器实现相关，这一点务必要注意，否则版本移植的时候要趟”坑”</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Skiplist</title>
    <url>/2023/03/19/C/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h1><p><a href="../images/pugh-skiplists-cacm1990.pdf">pugh-skiplists-cacm1990.pdf</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>柔性数组</title>
    <url>/2023/03/19/C/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h1><h2 id="柔性数组定义"><a href="#柔性数组定义" class="headerlink" title="柔性数组定义"></a>柔性数组定义</h2><p>C99中，结构体中<strong>最后一个元素</strong>允许是未知大小的数组，这个成员叫做结构体的柔性数组成员。</p>
<p>柔型数组有两种定义方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. typedef struct st_type</span><br><span class="line">2. &#123;</span><br><span class="line">3.  int i;</span><br><span class="line">4.  int a[0];//柔性数组成员</span><br><span class="line">5. &#125;type_a;</span><br></pre></td></tr></table></figure>

<p>有些编译器会报错无法编译可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. typedef struct st_type</span><br><span class="line">2. &#123;</span><br><span class="line">3.  int i;</span><br><span class="line">4.  int a[];//柔性数组成员</span><br><span class="line">5. &#125;type_a;</span><br></pre></td></tr></table></figure>

<h2 id="柔性数组的特点"><a href="#柔性数组的特点" class="headerlink" title="柔性数组的特点"></a>柔性数组的特点</h2><p>（1）结构中的柔性数组成员 前面必须至少包含一个其他成员（从上面的代码可以看出）</p>
<p>（2）sizeof( )返回的这种结构大小不包括柔性数组的内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. typedef struct st_type</span><br><span class="line">4. &#123;</span><br><span class="line">5.  int i;</span><br><span class="line">6.  int a[0];//柔性数组成员</span><br><span class="line">7. &#125;type_a;</span><br><span class="line">8. </span><br><span class="line">9. int main()</span><br><span class="line">10. &#123;</span><br><span class="line">11.   printf(&quot;sizeof(type_a) = %d\n&quot;, sizeof(type_a));</span><br><span class="line">12.   return 0;</span><br><span class="line">13. &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为4可以看出特点(2) : 返回的结构大小不包括柔性数组的大小</p>
<p><img src="/images/C_1.png"></p>
<p>（3）包含柔型数组成员的结构用malloc( )函数进行内存的动态分配，并且分配的内存应该大于结构的大小。以适应柔型数组的预期大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. #include&lt;stdlib.h&gt;</span><br><span class="line">4. typedef struct st_type</span><br><span class="line">5. &#123;</span><br><span class="line">6.  int i;</span><br><span class="line">7.  int a[0];//柔性数组成员</span><br><span class="line">8. &#125;type_a;</span><br><span class="line">9. </span><br><span class="line">10. int main()</span><br><span class="line">11. &#123;</span><br><span class="line">12.   type_a* s = (type_a*)malloc(sizeof(type_a) + 10 * sizeof(int));//根据特点3，malloc申请的空间应该比结构体大小要大</span><br><span class="line">13.   if (s != NULL)</span><br><span class="line">14.   &#123;</span><br><span class="line">15.     s-&gt;i = 10;</span><br><span class="line">16.     int j = 0;</span><br><span class="line">17.     for (j = 0; j &lt; 10; j++)</span><br><span class="line">18.     &#123;</span><br><span class="line">19.       s-&gt;a[j] = j;</span><br><span class="line">20.     &#125;</span><br><span class="line">21.   &#125;</span><br><span class="line">22. </span><br><span class="line">23.   return 0;</span><br><span class="line">24. &#125;</span><br><span class="line">25.</span><br></pre></td></tr></table></figure>

<p><img src="/images/C_2.png"></p>
<p>VS2019   F10    监视内存，输入s ，内存如下所示：</p>
<p><img src="/images/C_3.png"></p>
<p>如果想增加数组元素，使用realloc调整结构体大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. #define  _CRT_SECURE_NO_WARNINGS  1</span><br><span class="line">2. #include&lt;stdio.h&gt;</span><br><span class="line">3. #include&lt;stdlib.h&gt;</span><br><span class="line">4. typedef struct st_type</span><br><span class="line">5. &#123;</span><br><span class="line">6.  int i;</span><br><span class="line">7.  int a[0];//柔性数组成员</span><br><span class="line">8. &#125;type_a;</span><br><span class="line">9. </span><br><span class="line">10. int main()</span><br><span class="line">11. &#123;</span><br><span class="line">12.   //printf(&quot;sizeof(type_a) = %d\n&quot;, sizeof(type_a));</span><br><span class="line">13.   type_a* s = (type_a*)malloc(sizeof(type_a) + 10 * sizeof(int));//根据特点3，malloc申请的空间应该比结构体大小要大</span><br><span class="line">14.   if (s != NULL)</span><br><span class="line">15.   &#123;</span><br><span class="line">16.     s-&gt;i = 10;</span><br><span class="line">17.     int j = 0;</span><br><span class="line">18.     for (j = 0; j &lt; 10; j++)</span><br><span class="line">19.     &#123;</span><br><span class="line">20.       s-&gt;a[j] = j;</span><br><span class="line">21.     &#125;</span><br><span class="line">22.   &#125;</span><br><span class="line">23. </span><br><span class="line">24.   type_a* ptr = (type_a*)realloc(s,sizeof(type_a) + 20 * sizeof(int));//使用realloc重新调整结构体大小</span><br><span class="line">25.   if (ptr != NULL)</span><br><span class="line">26.   &#123;</span><br><span class="line">27.     s = ptr;</span><br><span class="line">28.   &#125;</span><br><span class="line">29. </span><br><span class="line">30.   //使用</span><br><span class="line">31. </span><br><span class="line">32.   //释放</span><br><span class="line">33.   free(s);</span><br><span class="line">34.   s = NULL;</span><br><span class="line">35. </span><br><span class="line">36.   return 0;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br></pre></td></tr></table></figure>

<h2 id="柔性数组的优势"><a href="#柔性数组的优势" class="headerlink" title="柔性数组的优势"></a>柔性数组的优势</h2><p>（1）把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以。</p>
<p>（2）连续的内存有益于提高访问速度，也有益于减少内存碎片。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Do not edit</title>
    <url>/2024/06/02/C/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E9%93%BE%E6%8E%A5%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="动态链接库链接顺序"><a href="#动态链接库链接顺序" class="headerlink" title="动态链接库链接顺序"></a>动态链接库链接顺序</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>-L 用于链接时指定显示链接的库的搜索路径（优先级高）</li>
<li>-rpath 用于在链接时指定直接或间接链接的库搜索路径（最高优先级），并且(写入二进制文件中RPATH)指定运行时的本二进制文件的直接或间接依赖的动态加载库搜索路径（最高优先级）。注：有些系统默认开启链接选项-enable-new-dtags,导致-rpath生成RUNPATH。通过指定链接选项-disable-new-dtags来使其生成RPATH。</li>
<li>-rpath-link 用于在链接时指定直接或间接链接的库搜索路径（优先级高）。</li>
<li>LD_LIBRARY_PATH 在运行时搜索直接或间接依赖。优先级低于RPATH为第二优先级</li>
<li>RUNPATH写入在二进制文件中，用于指定运行时本二进制文件的直接依赖动态加载库搜索路径(优先级低于LD_LIBRARY_PATH)。存在时覆盖二进制文件中RPATH。</li>
</ol>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li>ldd -s lib_path</li>
<li>LD_DEBUG&#x3D;libs lib_path</li>
<li>readelf -d lib_path</li>
<li>cmake 设置rpath指令</li>
<li>chrpath -r [new_rpath] [lib_name] 注:只能改路径比原来短的.</li>
<li>patchelf –set-rpath [new_rpath] [lib_name] 注:没有限制路径长度,但是修改的是RUNPATH</li>
</ol>
]]></content>
      <categories>
        <category>Do not edit</category>
      </categories>
  </entry>
  <entry>
    <title>静态成员</title>
    <url>/2023/02/12/C++/C++%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>我们可以使用 <strong>static</strong> 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>
<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<h1 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h1><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。</p>
<p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
<p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>
<blockquote>
<p><strong>静态成员函数与普通成员函数的区别：</strong></p>
<ul>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AES_NI</title>
    <url>/2023/09/10/Encryption/AES_NI/</url>
    <content><![CDATA[<h1 id="AES-NI"><a href="#AES-NI" class="headerlink" title="AES_NI"></a>AES_NI</h1><h2 id="How-to-find-out-AES-NI-Advanced-Encryption-Enabled-on-Linux-System"><a href="#How-to-find-out-AES-NI-Advanced-Encryption-Enabled-on-Linux-System" class="headerlink" title="How to find out AES-NI (Advanced Encryption) Enabled on Linux System"></a>How to find out AES-NI (Advanced Encryption) Enabled on Linux System</h2><p>One can find out that the processor has the AES&#x2F;AES-NI instruction set using the lscpu command:</p>
<blockquote>
<p>lscpu</p>
</blockquote>
<p>Type the following grep command to make sure that the processor has the AES instruction set and enabled in the BIOS:</p>
<blockquote>
<p>grep -o aes &#x2F;proc&#x2F;cpuinfo</p>
</blockquote>
<p>OR</p>
<blockquote>
<p>grep -m1 -o aes &#x2F;proc&#x2F;cpuinfo</p>
</blockquote>
]]></content>
      <categories>
        <category>Encryption</category>
      </categories>
  </entry>
  <entry>
    <title>初始化Git仓库</title>
    <url>/2023/02/12/Git/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h1><p>$ cd &#x2F;home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo&#x2F;<br>$ cd gitrepo</p>
<p>$ git init –bare runoob.git<br>Initialized empty Git repository in &#x2F;home&#x2F;gitrepo&#x2F;runoob.git&#x2F;</p>
<p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<p>$ chown -R git:git runoob.git</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>内联函数</title>
    <url>/2023/02/12/C++/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>C++ <strong>内联函数</strong>是通常与类一起使用。如果一个函数是内联的，那么<strong>在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方</strong>,对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>全密态数据库</title>
    <url>/2023/03/28/Database/%E5%85%A8%E5%AF%86%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="全密态数据库"><a href="#全密态数据库" class="headerlink" title="全密态数据库"></a>全密态数据库</h1><p>可信硬件(TEE)</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h2><ol>
<li><p>密钥管理</p>
</li>
<li><p>索引</p>
</li>
<li><p>TEE计算</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
  </entry>
  <entry>
    <title>Base64</title>
    <url>/2023/09/10/Code/Base64/</url>
    <content><![CDATA[<h1 id="Base64-Wikipedia"><a href="#Base64-Wikipedia" class="headerlink" title="Base64 - Wikipedia"></a>Base64 - Wikipedia</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>In computer programming, Base64 is a group of binary-to-text encoding schemes that represent binary data (more specifically, a sequence of 8-bit bytes) in sequences of 24 bits that can be represented by four 6-bit Base64 digits.</p>
</blockquote>
<hr>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_programming" title="Computer programming">computer programming</a>, <strong>Base64</strong> is a group of <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding" title="Binary-to-text encoding">binary-to-text encoding</a> schemes that represent <a href="https://en.wikipedia.org/wiki/Binary_data" title="Binary data">binary data</a> (more specifically, a sequence of 8-bit <a href="https://en.wikipedia.org/wiki/Byte" title="Byte">bytes</a>) in sequences of 24 <a href="https://en.wikipedia.org/wiki/Bit" title="Bit">bits</a> that can be represented by four 6-bit Base64 digits.</p>
<p>Common to all binary-to-text encoding schemes, Base64 is designed to carry data stored in binary formats across channels that only reliably support text content. Base64 is particularly prevalent on the <a href="https://en.wikipedia.org/wiki/World_Wide_Web" title="World Wide Web">World Wide Web</a><sup id="cite_ref-1"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-1">[1]</a></sup> where one of its uses is the ability to embed <a href="https://en.wikipedia.org/wiki/Image_files" title="Image files">image files</a> or other binary assets inside textual assets such as <a href="https://en.wikipedia.org/wiki/HTML" title="HTML">HTML</a> and <a href="https://en.wikipedia.org/wiki/CSS" title="CSS">CSS</a> files.<sup id="cite_ref-2"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-2">[2]</a></sup></p>
<p>Base64 is also widely used for sending <a href="https://en.wikipedia.org/wiki/E-mail" title="E-mail">e-mail</a> attachments. This is required because <a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" title="Simple Mail Transfer Protocol">SMTP</a> – in its original form – was designed to transport <a href="https://en.wikipedia.org/wiki/7-bit_ASCII" title="7-bit ASCII">7-bit ASCII</a> characters only. This encoding causes an overhead of 33–37% (33% by the encoding itself; up to 4% more by the inserted line breaks).</p>
<h2 id="Design-edit"><a href="#Design-edit" class="headerlink" title="Design[edit]"></a>Design[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=1" title="Edit section: Design">edit</a>]</h2><p>The particular set of 64 characters chosen to represent the 64-digit values for the base varies between implementations. The general strategy is to choose 64 characters that are common to most encodings and that are also <a href="https://en.wikipedia.org/wiki/Graphic_character" title="Graphic character">printable</a>. This combination leaves the data unlikely to be modified in transit through information systems, such as email, that were traditionally not <a href="https://en.wikipedia.org/wiki/8-bit_clean" title="8-bit clean">8-bit clean</a>.<sup id="cite_ref-autogenerated2006_3-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-autogenerated2006-3">[3]</a></sup> For example, <a href="https://en.wikipedia.org/wiki/MIME" title="MIME">MIME</a>‘s Base64 implementation uses <code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code>, and <code>0</code>–<code>9</code> for the first 62 values. Other variations share this property but differ in the symbols chosen for the last two values; an example is <a href="https://en.wikipedia.org/wiki/UTF-7" title="UTF-7">UTF-7</a>.</p>
<p>The earliest instances of this type of encoding were created for dial-up communication between systems running the same <a href="https://en.wikipedia.org/wiki/Operating_system" title="Operating system">OS</a>, for example, <a href="https://en.wikipedia.org/wiki/Uuencoding" title="Uuencoding">uuencode</a> for <a href="https://en.wikipedia.org/wiki/UNIX" title="UNIX">UNIX</a> and <a href="https://en.wikipedia.org/wiki/BinHex" title="BinHex">BinHex</a> for the <a href="https://en.wikipedia.org/wiki/TRS-80" title="TRS-80">TRS-80</a> (later adapted for the <a href="https://en.wikipedia.org/wiki/Macintosh" title="Macintosh">Macintosh</a>), and could therefore make more assumptions about what characters were safe to use. For instance, uuencode uses uppercase letters, digits, and many punctuation characters, but no lowercase.<sup id="cite_ref-rfc_1421_4-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-rfc_1421-4">[4]</a></sup><sup id="cite_ref-rfc_2045_5-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-rfc_2045-5">[5]</a></sup><sup id="cite_ref-rfc_3548_6-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-rfc_3548-6">[6]</a></sup><sup id="cite_ref-autogenerated2006_3-1"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-autogenerated2006-3">[3]</a></sup></p>
<h2 id="Base64-table-from-RFC-4648-edit"><a href="#Base64-table-from-RFC-4648-edit" class="headerlink" title="Base64 table from RFC 4648[edit]"></a>Base64 table from RFC 4648[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=2" title="Edit section: Base64 table from RFC 4648">edit</a>]</h2><p>This is the Base64 alphabet defined in <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">RFC 4648 §4</a> . See also <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">Variants summary</a> (below).</p>
<table><tbody><tr><th scope="col">Index</th><th scope="col">Binary</th><th scope="col">Char</th><td rowspan="17"></td><th scope="col">Index</th><th scope="col">Binary</th><th scope="col">Char</th><td rowspan="17"></td><th scope="col">Index</th><th scope="col">Binary</th><th scope="col">Char</th><td rowspan="17"></td><th scope="col">Index</th><th scope="col">Binary</th><th scope="col">Char</th></tr><tr><td>0</td><td>000000</td><td><code>A</code></td><td>16</td><td>010000</td><td><code>Q</code></td><td>32</td><td>100000</td><td><code>g</code></td><td>48</td><td>110000</td><td><code>w</code></td></tr><tr><td>1</td><td>000001</td><td><code>B</code></td><td>17</td><td>010001</td><td><code>R</code></td><td>33</td><td>100001</td><td><code>h</code></td><td>49</td><td>110001</td><td><code>x</code></td></tr><tr><td>2</td><td>000010</td><td><code>C</code></td><td>18</td><td>010010</td><td><code>S</code></td><td>34</td><td>100010</td><td><code>i</code></td><td>50</td><td>110010</td><td><code>y</code></td></tr><tr><td>3</td><td>000011</td><td><code>D</code></td><td>19</td><td>010011</td><td><code>T</code></td><td>35</td><td>100011</td><td><code>j</code></td><td>51</td><td>110011</td><td><code>z</code></td></tr><tr><td>4</td><td>000100</td><td><code>E</code></td><td>20</td><td>010100</td><td><code>U</code></td><td>36</td><td>100100</td><td><code>k</code></td><td>52</td><td>110100</td><td><code>0</code></td></tr><tr><td>5</td><td>000101</td><td><code>F</code></td><td>21</td><td>010101</td><td><code>V</code></td><td>37</td><td>100101</td><td><code>l</code></td><td>53</td><td>110101</td><td><code>1</code></td></tr><tr><td>6</td><td>000110</td><td><code>G</code></td><td>22</td><td>010110</td><td><code>W</code></td><td>38</td><td>100110</td><td><code>m</code></td><td>54</td><td>110110</td><td><code>2</code></td></tr><tr><td>7</td><td>000111</td><td><code>H</code></td><td>23</td><td>010111</td><td><code>X</code></td><td>39</td><td>100111</td><td><code>n</code></td><td>55</td><td>110111</td><td><code>3</code></td></tr><tr><td>8</td><td>001000</td><td><code>I</code></td><td>24</td><td>011000</td><td><code>Y</code></td><td>40</td><td>101000</td><td><code>o</code></td><td>56</td><td>111000</td><td><code>4</code></td></tr><tr><td>9</td><td>001001</td><td><code>J</code></td><td>25</td><td>011001</td><td><code>Z</code></td><td>41</td><td>101001</td><td><code>p</code></td><td>57</td><td>111001</td><td><code>5</code></td></tr><tr><td>10</td><td>001010</td><td><code>K</code></td><td>26</td><td>011010</td><td><code>a</code></td><td>42</td><td>101010</td><td><code>q</code></td><td>58</td><td>111010</td><td><code>6</code></td></tr><tr><td>11</td><td>001011</td><td><code>L</code></td><td>27</td><td>011011</td><td><code>b</code></td><td>43</td><td>101011</td><td><code>r</code></td><td>59</td><td>111011</td><td><code>7</code></td></tr><tr><td>12</td><td>001100</td><td><code>M</code></td><td>28</td><td>011100</td><td><code>c</code></td><td>44</td><td>101100</td><td><code>s</code></td><td>60</td><td>111100</td><td><code>8</code></td></tr><tr><td>13</td><td>001101</td><td><code>N</code></td><td>29</td><td>011101</td><td><code>d</code></td><td>45</td><td>101101</td><td><code>t</code></td><td>61</td><td>111101</td><td><code>9</code></td></tr><tr><td>14</td><td>001110</td><td><code>O</code></td><td>30</td><td>011110</td><td><code>e</code></td><td>46</td><td>101110</td><td><code>u</code></td><td>62</td><td>111110</td><td><code>+</code></td></tr><tr><td>15</td><td>001111</td><td><code>P</code></td><td>31</td><td>011111</td><td><code>f</code></td><td>47</td><td>101111</td><td><code>v</code></td><td>63</td><td>111111</td><td><code>/</code></td></tr><tr><td colspan="2" data-sort-value>Padding</td><td>=</td><td colspan="12"></td></tr></tbody></table>

<h2 id="Examples-edit"><a href="#Examples-edit" class="headerlink" title="Examples[edit]"></a>Examples[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=3" title="Edit section: Examples">edit</a>]</h2><p>The example below uses <a href="https://en.wikipedia.org/wiki/ASCII" title="ASCII">ASCII</a> text for simplicity, but this is not a typical use case, as it can already be safely transferred across all systems that can handle Base64. The more typical use is to encode <a href="https://en.wikipedia.org/wiki/Binary_data" title="Binary data">binary data</a> (such as an image); the resulting Base64 data will only contain 64 different ASCII characters, all of which can reliably be transferred across systems that may corrupt the raw source bytes.</p>
<p>Here is a well-known <a href="https://en.wikipedia.org/wiki/Idiom" title="Idiom">idiom</a> from <a href="https://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing">distributed computing</a>:</p>
<blockquote>
<p>Many hands make light work.</p>
</blockquote>
<p>When the quote (without trailing whitespace) is encoded into Base64, it is represented as a byte sequence of 8-bit-padded <a href="https://en.wikipedia.org/wiki/ASCII" title="ASCII">ASCII</a> characters encoded in <a href="https://en.wikipedia.org/wiki/MIME" title="MIME">MIME</a>‘s Base64 scheme as follows (newlines and white spaces may be present anywhere but are to be ignored on decoding):</p>
<blockquote>
<p>TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu</p>
</blockquote>
<p>In the above quote, the encoded value of <em>Man</em> is <em>TWFu</em>. Encoded in ASCII, the characters <em>M</em>, <em>a</em>, and <em>n</em> are stored as the byte values <code>77</code>, <code>97</code>, and <code>110</code>, which are the 8-bit binary values <code>01001101</code>, <code>01100001</code>, and <code>01101110</code>. These three values are joined together into a 24-bit string, producing <code>010011010110000101101110</code>. Groups of 6 bits (6 bits have a maximum of 2<sup>6</sup> &#x3D; 64 different binary values) are <a href="https://en.wikipedia.org/wiki/Binary_number#Counting_in_binary" title="Binary number">converted into individual numbers</a> from start to end (in this case, there are four numbers in a 24-bit string), which are then converted into their corresponding Base64 character values.</p>
<p>As this example illustrates, Base64 encoding converts three <a href="https://en.wikipedia.org/wiki/Octet_(computing)" title="Octet (computing)">octets</a> into four encoded characters.</p>
<table><tbody><tr><th rowspan="2" scope="row">Source</th><th scope="row">Text (ASCII)</th><td colspan="8">M</td><td colspan="8">a</td><td colspan="8">n</td></tr><tr><th scope="row">Octets</th><td colspan="8">77 (0x4d)</td><td colspan="8">97 (0x61)</td><td colspan="8">110 (0x6e)</td></tr><tr><th colspan="2" scope="row">Bits</th><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><th rowspan="3" scope="row">Base64<br>encoded</th><th scope="row">Sextets</th><td colspan="6">19</td><td colspan="6">22</td><td colspan="6">5</td><td colspan="6">46</td></tr><tr><th scope="row">Character</th><td colspan="6">T</td><td colspan="6">W</td><td colspan="6">F</td><td colspan="6">u</td></tr><tr><th scope="row">Octets</th><td colspan="6">84 (0x54)</td><td colspan="6">87 (0x57)</td><td colspan="6">70 (0x46)</td><td colspan="6">117 (0x75)</td></tr></tbody></table>

<p><code>=</code> padding characters might be added to make the last encoded block contain four Base64 characters.</p>
<p><a href="https://en.wikipedia.org/wiki/Hexadecimal" title="Hexadecimal">Hexadecimal</a> to <a href="https://en.wikipedia.org/wiki/Octal" title="Octal">octal</a> transformation is useful to convert between binary and Base64. Such conversion is available for both advanced calculators and programming languages. For example, the hexadecimal representation of the 24 bits above is 4D616E. The octal representation is 23260556. Those 8 octal digits can be split into pairs (23 26 05 56), and each pair is converted to decimal to yield 19 22 05 46. Using those four decimal numbers as indices for the Base64 alphabet, the corresponding ASCII characters are <em>TWFu</em>.</p>
<p>If there are only two significant input octets (e.g., ‘Ma’), or when the last input group contains only two octets, all 16 bits will be captured in the first three Base64 digits (18 bits); the two <a href="https://en.wikipedia.org/wiki/Least_significant_bit" title="Least significant bit">least significant bits</a> of the last content-bearing 6-bit block will turn out to be zero, and discarded on decoding (along with the succeeding <code>=</code> padding character):</p>
<table><tbody><tr><th rowspan="2" scope="row">Source</th><th scope="row">Text (ASCII)</th><td colspan="8">M</td><td colspan="8">a</td><td colspan="8" rowspan="2" data-sort-value></td></tr><tr><th scope="row">Octets</th><td colspan="8">77 (0x4d)</td><td colspan="8">97 (0x61)</td></tr><tr><th colspan="2" scope="row">Bits</th><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td></tr><tr><th rowspan="3" scope="row">Base64<br>encoded</th><th scope="row">Sextets</th><td colspan="6">19</td><td colspan="6">22</td><td colspan="6">4</td><td colspan="6" data-sort-value>Padding</td></tr><tr><th scope="row">Character</th><td colspan="6">T</td><td colspan="6">W</td><td colspan="6">E</td><td colspan="6">=</td></tr><tr><th scope="row">Octets</th><td colspan="6">84 (0x54)</td><td colspan="6">87 (0x57)</td><td colspan="6">69 (0x45)</td><td colspan="6">61 (0x3D)</td></tr></tbody></table>

<p>If there is only one significant input octet (e.g., ‘M’), or when the last input group contains only one octet, all 8 bits will be captured in the first two Base64 digits (12 bits); the four <a href="https://en.wikipedia.org/wiki/Least_significant_bit" title="Least significant bit">least significant bits</a> of the last content-bearing 6-bit block will turn out to be zero, and discarded on decoding (along with the succeeding two <code>=</code> padding characters):</p>
<table><tbody><tr><th rowspan="2" scope="row">Source</th><th scope="row">Text (ASCII)</th><td colspan="8">M</td><td colspan="16" rowspan="2" data-sort-value></td></tr><tr><th scope="row">Octets</th><td colspan="8">77 (0x4d)</td></tr><tr><th colspan="2" scope="row">Bits</th><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td><td data-sort-value><span> </span></td></tr><tr><th rowspan="3" scope="row">Base64<br>encoded</th><th scope="row">Sextets</th><td colspan="6">19</td><td colspan="6">16</td><td colspan="6" data-sort-value>Padding</td><td colspan="6" data-sort-value>Padding</td></tr><tr><th scope="row">Character</th><td colspan="6">T</td><td colspan="6">Q</td><td colspan="6">=</td><td colspan="6">=</td></tr><tr><th scope="row">Octets</th><td colspan="6">84 (0x54)</td><td colspan="6">81 (0x51)</td><td colspan="6">61 (0x3D)</td><td colspan="6">61 (0x3D)</td></tr></tbody></table>

<h3 id="Output-padding-edit"><a href="#Output-padding-edit" class="headerlink" title="Output padding[edit]"></a>Output padding[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=4" title="Edit section: Output padding">edit</a>]</h3><p>Because Base64 is a six-bit encoding, and because the decoded values are divided into 8-bit octets, every four characters of Base64-encoded text (4 sextets &#x3D; 4 × 6 &#x3D; 24 bits) represents three octets of unencoded text or data (3 octets &#x3D; 3 × 8 &#x3D; 24 bits). This means that when the length of the unencoded input is not a multiple of three, the encoded output must have padding added so that its length is a multiple of four. The padding character is <code>=</code>, which indicates that no further bits are needed to fully encode the input. (This is different from <code>A</code>, which means that the remaining bits are all zeros.) The example below illustrates how truncating the input of the above quote changes the output padding:</p>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
<th>Padding</th>
</tr>
</thead>
<tbody><tr>
<td>Text</td>
<td>Length</td>
<td>Text</td>
</tr>
<tr>
<td><em>light work.</em></td>
<td>11</td>
<td>bGlnaHQgd29yay4&#x3D;</td>
</tr>
<tr>
<td><em>light work</em></td>
<td>10</td>
<td>bGlnaHQgd29yaw&#x3D;&#x3D;</td>
</tr>
<tr>
<td><em>light wor</em></td>
<td>9</td>
<td>bGlnaHQgd29y</td>
</tr>
<tr>
<td><em>light wo</em></td>
<td>8</td>
<td>bGlnaHQgd28&#x3D;</td>
</tr>
<tr>
<td><em>light w</em></td>
<td>7</td>
<td>bGlnaHQgdw&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<p>The padding character is not essential for decoding, since the number of missing bytes can be inferred from the length of the encoded text. In some implementations, the padding character is mandatory, while for others it is not used. An exception in which padding characters are required is when multiple Base64 encoded files have been concatenated.</p>
<h3 id="Decoding-Base64-with-padding-edit"><a href="#Decoding-Base64-with-padding-edit" class="headerlink" title="Decoding Base64 with padding[edit]"></a>Decoding Base64 with padding[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=5" title="Edit section: Decoding Base64 with padding">edit</a>]</h3><p>When decoding Base64 text, four characters are typically converted back to three bytes. The only exceptions are when padding characters exist. A single <code>=</code> indicates that the four characters will decode to only two bytes, while <code>==</code> indicates that the four characters will decode to only a single byte. For example:</p>
<table>
<thead>
<tr>
<th>Encoded</th>
<th>Padding</th>
<th>Length</th>
<th>Decoded</th>
</tr>
</thead>
<tbody><tr>
<td>bGlnaHQgdw&#x3D;&#x3D;</td>
<td><code>==</code></td>
<td>1</td>
<td><em>light w</em></td>
</tr>
<tr>
<td>bGlnaHQgd28&#x3D;</td>
<td><code>=</code></td>
<td>2</td>
<td><em>light wo</em></td>
</tr>
<tr>
<td>bGlnaHQgd29y</td>
<td>None</td>
<td>3</td>
<td><em>light wor</em></td>
</tr>
</tbody></table>
<p>Another way to interpret the padding character is to consider it as an instruction to discard 2 trailing bits from the bit string each time a <code>=</code> is encountered. For example, when `bGlnaHQgdw&#x3D;&#x3D;` is decoded, we convert each character (except the trailing occurrences of <code>=</code>) into their corresponding 6-bit representation, and then discard 2 trailing bits for the first <code>=</code> and another 2 trailing bits for the other <code>=</code>. In this instance, we would get 6 bits from the <code>d</code>, and another 6 bits from the <code>w</code> for a bit string of length 12, but since we remove 2 bits for each <code>=</code> (for a total of 4 bits), the <code>dw==</code> ends up producing 8 bits (1 byte) when decoded.</p>
<h3 id="Decoding-Base64-without-padding-edit"><a href="#Decoding-Base64-without-padding-edit" class="headerlink" title="Decoding Base64 without padding[edit]"></a>Decoding Base64 without padding[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=6" title="Edit section: Decoding Base64 without padding">edit</a>]</h3><p>Without padding, after normal decoding of four characters to three bytes over and over again, fewer than four encoded characters may remain. In this situation, only two or three characters can remain. A single remaining encoded character is not possible, because a single Base64 character only contains 6 bits, and 8 bits are required to create a byte, so a minimum of two Base64 characters are required: The first character contributes 6 bits, and the second character contributes its first 2 bits. For example:</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Encoded</th>
<th>Length</th>
<th>Decoded</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>bGlnaHQgdw</td>
<td>1</td>
<td><em>light w</em></td>
</tr>
<tr>
<td>3</td>
<td>bGlnaHQgd28</td>
<td>2</td>
<td><em>light wo</em></td>
</tr>
<tr>
<td>4</td>
<td>bGlnaHQgd29y</td>
<td>3</td>
<td><em>light wor</em></td>
</tr>
</tbody></table>
<h2 id="Implementations-and-history-edit"><a href="#Implementations-and-history-edit" class="headerlink" title="Implementations and history[edit]"></a>Implementations and history[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=7" title="Edit section: Implementations and history">edit</a>]</h2><h3 id="Variants-summary-table-edit"><a href="#Variants-summary-table-edit" class="headerlink" title="Variants summary table[edit]"></a>Variants summary table[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=8" title="Edit section: Variants summary table">edit</a>]</h3><p>Implementations may have some constraints on the alphabet used for representing some bit patterns. This notably concerns the last two characters used in the alphabet at positions 62 and 63, and the character used for padding (which may be mandatory in some protocols or removed in others). The table below summarizes these known variants and provides links to the subsections below.</p>
<table>
<thead>
<tr>
<th>Encoding</th>
<th>Encoding characters</th>
<th>Separate encoding of lines</th>
<th>Decoding non-encoding characters</th>
</tr>
</thead>
<tbody><tr>
<td>62nd</td>
<td>63rd</td>
<td><em>pad</em></td>
<td>Separators</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc1421">RFC 1421</a>: Base64 for <a href="https://en.wikipedia.org/wiki/Base64#Privacy-enhanced_mail">Privacy-Enhanced Mail</a> (deprecated)</td>
<td><code>+</code></td>
<td><code>/</code></td>
<td><code>=</code> mandatory</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc2045">RFC 2045</a>: Base64 transfer encoding for <a href="https://en.wikipedia.org/wiki/Base64#MIME">MIME</a></td>
<td><code>+</code></td>
<td><code>/</code></td>
<td><code>=</code> mandatory</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc2152">RFC 2152</a>: Base64 for <a href="https://en.wikipedia.org/wiki/Base64#UTF-7">UTF-7</a></td>
<td><code>+</code></td>
<td><code>/</code></td>
<td>No</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc3501#section-5.1.3">RFC 3501</a>: Base64 encoding for IMAP mailbox names</td>
<td><code>+</code></td>
<td><code>,</code></td>
<td>No</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">RFC 4648 §4</a>: base64 (standard)<sup id="cite_ref-common_7-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-common-7">[a]</a></sup></td>
<td><code>+</code></td>
<td><code>/</code></td>
<td><code>=</code> optional</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc4648#section-5">RFC 4648 §5</a>: base64url (URL- and filename-safe standard)<sup id="cite_ref-common_7-1"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-common-7">[a]</a></sup></td>
<td><code>-</code></td>
<td><code>_</code></td>
<td><code>=</code> optional</td>
</tr>
<tr>
<td><a href="https://datatracker.ietf.org/doc/html/rfc4880">RFC 4880</a>: Radix-64 for <a href="https://en.wikipedia.org/wiki/Base64#OpenPGP">OpenPGP</a></td>
<td><code>+</code></td>
<td><code>/</code></td>
<td><code>=</code> mandatory</td>
</tr>
<tr>
<td>Other variations</td>
<td>see <a href="https://en.wikipedia.org/wiki/Base64#Applications_not_compatible_with_RFC_4648_Base64">Applications not compatible with RFC 4648 Base64</a> (below)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>^ <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-common_7-0">Jump up to: <sup><i><b>a</b></i></sup></a> <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-common_7-1"><sup><i><b>b</b></i></sup></a> It is important to note that this variant is intended to provide common features where they are not desired to be specialized by implementations, ensuring robust engineering. This is particularly in light of separate line encodings and restrictions, which have not been considered when previous standards have been co-opted for use elsewhere. Thus, the features indicated here may be overridden.</li>
</ol>
<h3 id="Privacy-enhanced-mail-edit"><a href="#Privacy-enhanced-mail-edit" class="headerlink" title="Privacy-enhanced mail[edit]"></a>Privacy-enhanced mail[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=9" title="Edit section: Privacy-enhanced mail">edit</a>]</h3><p>The first known standardized use of the encoding now called MIME Base64 was in the <a href="https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail" title="Privacy-enhanced Electronic Mail">Privacy-enhanced Electronic Mail</a> (PEM) protocol, proposed by <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc989">989</a> in 1987. PEM defines a “printable encoding” scheme that uses Base64 encoding to transform an arbitrary sequence of <a href="https://en.wikipedia.org/wiki/Octet_(computing)" title="Octet (computing)">octets</a> to a format that can be expressed in short lines of 6-bit characters, as required by transfer protocols such as <a href="https://en.wikipedia.org/wiki/SMTP" title="SMTP">SMTP</a>.<sup id="cite_ref-8"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-8">[7]</a></sup></p>
<p>The current version of PEM (specified in <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1421">1421</a>) uses a 64-character alphabet consisting of upper- and lower-case <a href="https://en.wikipedia.org/wiki/Roman_letters" title="Roman letters">Roman letters</a> (<code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code>), the numerals (<code>0</code>–<code>9</code>), and the <code>+</code> and <code>/</code> symbols. The <code>=</code> symbol is also used as a padding suffix.<sup id="cite_ref-rfc_1421_4-1"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-rfc_1421-4">[4]</a></sup> The original specification, <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc989">989</a>, additionally used the <code>*</code> symbol to delimit encoded but unencrypted data within the output stream.</p>
<p>To convert data to PEM printable encoding, the first byte is placed in the <a href="https://en.wikipedia.org/wiki/Most_significant_bit" title="Most significant bit">most significant</a> eight bits of a 24-bit <a href="https://en.wikipedia.org/wiki/Data_buffer" title="Data buffer">buffer</a>, the next in the middle eight, and the third in the <a href="https://en.wikipedia.org/wiki/Least_significant_bit" title="Least significant bit">least significant</a> eight bits. If there are fewer than three bytes left to encode (or in total), the remaining buffer bits will be zero. The buffer is then used, six bits at a time, most significant first, as indices into the string: “<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>“, and the indicated character is output.</p>
<p>The process is repeated on the remaining data until fewer than four octets remain. If three octets remain, they are processed normally. If fewer than three octets (24 bits) are remaining to encode, the input data is right-padded with zero bits to form an integral multiple of six bits.</p>
<p>After encoding the non-padded data, if two octets of the 24-bit buffer are padded-zeros, two <code>=</code> characters are appended to the output; if one octet of the 24-bit buffer is filled with padded-zeros, one <code>=</code> character is appended. This signals the decoder that the zero bits added due to padding should be excluded from the reconstructed data. This also guarantees that the encoded output length is a multiple of 4 bytes.</p>
<p>PEM requires that all encoded lines consist of exactly 64 printable characters, with the exception of the last line, which may contain fewer printable characters. Lines are delimited by whitespace characters according to local (platform-specific) conventions.</p>
<h3 id="MIME-edit"><a href="#MIME-edit" class="headerlink" title="MIME[edit]"></a>MIME[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=10" title="Edit section: MIME">edit</a>]</h3><p>Main article: <a href="https://en.wikipedia.org/wiki/MIME" title="MIME">MIME</a></p>
<p>The <a href="https://en.wikipedia.org/wiki/MIME" title="MIME">MIME</a> (Multipurpose Internet Mail Extensions) specification lists Base64 as one of two <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding" title="Binary-to-text encoding">binary-to-text encoding</a> schemes (the other being <a href="https://en.wikipedia.org/wiki/Quoted-printable" title="Quoted-printable">quoted-printable</a>).<sup id="cite_ref-RFC_2045_9-0"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-RFC_2045-9">[8]</a></sup> MIME’s Base64 encoding is based on that of the <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1421">1421</a> version of PEM: it uses the same 64-character alphabet and encoding mechanism as PEM and uses the <code>=</code> symbol for output padding in the same way, as described at <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2045">2045</a>.</p>
<p>MIME does not specify a fixed length for Base64-encoded lines, but it does specify a maximum line length of 76 characters. Additionally, it specifies that any character outside the standard set of 64 encoding characters (For example CRLF sequences), must be ignored by a compliant decoder, although most implementations use a CR&#x2F;LF <a href="https://en.wikipedia.org/wiki/Newline" title="Newline">newline</a> pair to delimit encoded lines.</p>
<p>Thus, the actual length of MIME-compliant Base64-encoded binary data is usually about 137% of the original data length (4⁄3×78⁄76), though for very short messages the overhead can be much higher due to the overhead of the headers. Very roughly, the final size of Base64-encoded binary data is equal to 1.37 times the original data size + 814 bytes (for headers). The size of the decoded data can be approximated with this formula:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes = (string_length(encoded_string) − 814) / 1.37</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UTF-7-edit"><a href="#UTF-7-edit" class="headerlink" title="UTF-7[edit]"></a>UTF-7[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=11" title="Edit section: UTF-7">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/UTF-7" title="UTF-7">UTF-7</a>, described first in <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1642">1642</a>, which was later superseded by <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2152">2152</a>, introduced a system called <em>modified Base64</em>. This data encoding scheme is used to encode <a href="https://en.wikipedia.org/wiki/UTF-16" title="UTF-16">UTF-16</a> as <a href="https://en.wikipedia.org/wiki/ASCII" title="ASCII">ASCII</a> characters for use in 7-bit transports such as <a href="https://en.wikipedia.org/wiki/SMTP" title="SMTP">SMTP</a>. It is a variant of the Base64 encoding used in MIME.<sup id="cite_ref-10"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-10">[9]</a></sup><sup id="cite_ref-11"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-11">[10]</a></sup></p>
<p>The “Modified Base64” alphabet consists of the MIME Base64 alphabet, but does not use the “<code>=</code>“ padding character. UTF-7 is intended for use in mail headers (defined in <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2047">2047</a>), and the “<code>=</code>“ character is reserved in that context as the escape character for “quoted-printable” encoding. Modified Base64 simply omits the padding and ends immediately after the last Base64 digit containing useful bits leaving up to three unused bits in the last Base64 digit.</p>
<h3 id="OpenPGP-edit"><a href="#OpenPGP-edit" class="headerlink" title="OpenPGP[edit]"></a>OpenPGP[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=12" title="Edit section: OpenPGP">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/OpenPGP" title="OpenPGP">OpenPGP</a>, described in <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc4880">4880</a>, describes <strong>Radix-64</strong> encoding, also known as “<a href="https://en.wikipedia.org/wiki/ASCII_armor" title="ASCII armor">ASCII armor</a>“. Radix-64 is identical to the “Base64” encoding described by MIME, with the addition of an optional 24-bit <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" title="Cyclic redundancy check">CRC</a>. The <a href="https://en.wikipedia.org/wiki/Checksum" title="Checksum">checksum</a> is calculated on the input data before encoding; the checksum is then encoded with the same Base64 algorithm and, prefixed by the “<code>=</code>“ symbol as the separator, appended to the encoded output data.<sup id="cite_ref-12"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-12">[11]</a></sup></p>
<h3 id="RFC-3548-edit"><a href="#RFC-3548-edit" class="headerlink" title="RFC 3548[edit]"></a>RFC 3548[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=13" title="Edit section: RFC 3548">edit</a>]</h3><p><a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc3548">3548</a>, entitled <em>The Base16, Base32, and Base64 Data Encodings</em>, is an informational (non-normative) memo that attempts to unify the <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1421">1421</a> and <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2045">2045</a> specifications of Base64 encodings, alternative-alphabet encodings, and the Base32 (which is seldom used) and Base16 encodings.</p>
<p>Unless implementations are written to a specification that refers to <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc3548">3548</a> and specifically requires otherwise, RFC 3548 forbids implementations from generating messages containing characters outside the encoding alphabet or without padding, and it also declares that decoder implementations must reject data that contain characters outside the encoding alphabet.<sup id="cite_ref-rfc_3548_6-1"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-rfc_3548-6">[6]</a></sup></p>
<h3 id="RFC-4648-edit"><a href="#RFC-4648-edit" class="headerlink" title="RFC 4648[edit]"></a>RFC 4648[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=14" title="Edit section: RFC 4648">edit</a>]</h3><p>This RFC obsoletes RFC 3548 and focuses on Base64&#x2F;32&#x2F;16:</p>
<p><em>This document describes the commonly used Base64, Base32, and Base16 encoding schemes. It also discusses the use of line feeds in encoded data, the use of padding in encoded data, the use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.</em></p>
<h3 id="URL-applications-edit"><a href="#URL-applications-edit" class="headerlink" title="URL applications[edit]"></a>URL applications[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=15" title="Edit section: URL applications">edit</a>]</h3><p>Base64 encoding can be helpful when fairly lengthy identifying information is used in an HTTP environment. For example, a database persistence framework for <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> objects might use Base64 encoding to encode a relatively large unique id (generally 128-bit <a href="https://en.wikipedia.org/wiki/UUID" title="UUID">UUIDs</a>) into a string for use as an HTTP parameter in HTTP forms or HTTP GET <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Locator" title="Uniform Resource Locator">URLs</a>. Also, many applications need to encode binary data in a way that is convenient for inclusion in URLs, including in hidden web form fields, and Base64 is a convenient encoding to render them in a compact way.</p>
<p>Using standard Base64 in <a href="https://en.wikipedia.org/wiki/URL" title="URL">URL</a> requires encoding of ‘<code>+</code>‘, ‘<code>/</code>‘ and ‘<code>=</code>‘ characters into special <a href="https://en.wikipedia.org/wiki/Percent-encoding" title="Percent-encoding">percent-encoded</a> hexadecimal sequences (‘<code>+</code>‘ becomes ‘<code>%2B</code>‘, ‘<code>/</code>‘ becomes ‘<code>%2F</code>‘ and ‘<code>=</code>‘ becomes ‘<code>%3D</code>‘), which makes the string unnecessarily longer.</p>
<p>For this reason, <strong>modified Base64 for URL</strong> variants exist (such as <strong>base64url</strong> in <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc4648">4648</a>), where the ‘<code>+</code>‘ and ‘<code>/</code>‘ characters of standard Base64 are respectively replaced by ‘<code>-</code>‘ and ‘<code>_</code>‘, so that using <a href="https://en.wikipedia.org/wiki/Percent-encoding" title="Percent-encoding">URL encoders&#x2F;decoders</a> is no longer necessary and has no effect on the length of the encoded value, leaving the same encoded form intact for use in relational databases, web forms, and object identifiers in general. A popular site to make use of such is <a href="https://en.wikipedia.org/wiki/YouTube#Uploading" title="YouTube">YouTube</a>.<sup id="cite_ref-13"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-13">[12]</a></sup> Some variants allow or require omitting the padding ‘<code>=</code>‘ signs to avoid them being confused with field separators, or require that any such padding be percent-encoded. Some libraries<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Avoid_weasel_words" title="Wikipedia:Avoid weasel words"><span title="The material near this tag possibly uses too vague attribution or weasel words. (December 2020)">which?</span></a></i>]</sup> will encode ‘<code>=</code>‘ to ‘<code>.</code>‘, potentially exposing applications to relative path attacks when a folder name is encoded from user data.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2022)">citation needed</span></a></i>]</sup></p>
<h3 id="HTML-edit"><a href="#HTML-edit" class="headerlink" title="HTML[edit]"></a>HTML[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=16" title="Edit section: HTML">edit</a>]</h3><p>The <code>atob()</code> and <code>btoa()</code> JavaScript methods, defined in the HTML5 draft specification,<sup id="cite_ref-14"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-14">[13]</a></sup> provide Base64 encoding and decoding functionality to web pages. The <code>btoa()</code> method outputs padding characters, but these are optional in the input of the <code>atob()</code> method. This is real life example website that uses <code>atob()</code> <a href="https://base64-encoder.com/">Base64-Encoder</a></p>
<h3 id="Other-applications-edit"><a href="#Other-applications-edit" class="headerlink" title="Other applications[edit]"></a>Other applications[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=17" title="Edit section: Other applications">edit</a>]</h3><p><a href="https://upload.wikimedia.org/wikipedia/commons/d/d3/35_mm_angle_of_view_vs_focal_length.svg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/35_mm_angle_of_view_vs_focal_length.svg/220px-35_mm_angle_of_view_vs_focal_length.svg.png"></a></p>
<p>Example of an SVG containing embedded JPEG images encoded in Base64<sup id="cite_ref-15"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-15">[14]</a></sup></p>
<p>Base64 can be used in a variety of contexts:</p>
<ul>
<li>Base64 can be used to transmit and store text that might otherwise cause <a href="https://en.wikipedia.org/wiki/Delimiter_collision" title="Delimiter collision">delimiter collision</a></li>
<li>Base64 is used to encode character strings in <a href="https://en.wikipedia.org/wiki/LDAP_Data_Interchange_Format" title="LDAP Data Interchange Format">LDAP Data Interchange Format</a> files</li>
<li>Base64 is often used to embed binary data in an <a href="https://en.wikipedia.org/wiki/XML" title="XML">XML</a> file, using a syntax similar to <code>&lt;data encoding=&quot;base64&quot;&gt;…&lt;/data&gt;</code> e.g. <a href="https://en.wikipedia.org/wiki/Favicon" title="Favicon">favicons</a> in <a href="https://en.wikipedia.org/wiki/Firefox" title="Firefox">Firefox</a>‘s exported <code>bookmarks.html</code>.</li>
<li>Base64 is used to encode binary files such as images within scripts, to avoid depending on external files.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" title="Data URI scheme">data URI scheme</a> can use Base64 to represent file contents. For instance, background images and fonts can be specified in a <a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets" title="Cascading Style Sheets">CSS</a> stylesheet file as <code>data:</code> URIs, instead of being supplied in separate files.</li>
<li>Although not part of the official specification for <a href="https://en.wikipedia.org/wiki/SVG" title="SVG">SVG</a>, some viewers can interpret Base64 when used for embedded elements, such as images inside SVG.<sup id="cite_ref-16"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-16">[15]</a></sup></li>
<li>Base64 can be used to store&#x2F;transmit relatively small amounts of binary data via a computer’s text <a href="https://en.wikipedia.org/wiki/Clipboard_(computing)" title="Clipboard (computing)">clipboard</a> functionality, especially in cases where the information doesn’t warrant being permanently saved or when information must be quickly sent between a wide variety of different, potentially incompatible programs. An example is the representation of the public keys of <a href="https://en.wikipedia.org/wiki/Cryptocurrency" title="Cryptocurrency">cryptocurrency</a> recipients as Base64 encoded text strings, which can be easily copied and pasted into users’ <a href="https://en.wikipedia.org/wiki/Cryptocurrency_wallet" title="Cryptocurrency wallet">wallet software</a>.</li>
<li>Binary data that must be quickly verified by humans as a safety mechanism, such as <a href="https://en.wikipedia.org/wiki/Checksum" title="Checksum">file checksums</a> or <a href="https://en.wikipedia.org/wiki/Public_key_fingerprint" title="Public key fingerprint">key fingerprints</a>, is often represented in Base64 for easy checking, sometimes with additional formattings, such as separating each group of four characters in the representation of a <a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy" title="Pretty Good Privacy">PGP</a> key fingerprint with a space.</li>
<li><a href="https://en.wikipedia.org/wiki/QR_code" title="QR code">QR codes</a> which contain binary data will sometimes store it encoded in Base64 rather than simply storing the raw binary data, as there is a stronger guarantee that all QR code readers will accurately decode text, as well as the fact that some devices will more readily save text from a QR code than potentially malicious binary data.</li>
</ul>
<h3 id="Applications-are-not-compatible-with-RFC-4648-Base64-edit"><a href="#Applications-are-not-compatible-with-RFC-4648-Base64-edit" class="headerlink" title="Applications are not compatible with RFC 4648 Base64[edit]"></a>Applications are not compatible with RFC 4648 Base64[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=18" title="Edit section: Applications are not compatible with RFC 4648 Base64">edit</a>]</h3><p>Some applications use a Base64 alphabet that is significantly different from the alphabets used in the most common Base64 variants (see <a href="https://en.wikipedia.org/wiki/Base64#Variants_summary_table">Variants summary table</a> above).</p>
<ul>
<li>The <strong><a href="https://en.wikipedia.org/wiki/Uuencoding" title="Uuencoding">Uuencoding</a></strong> alphabet includes no lowercase characters, instead using ASCII codes 32 (“ “ (space)) through 95 (“<code>_</code>“), consecutively. Uuencoding uses the alphabet “ <code>!&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_</code>“. Avoiding all lower-case letters was helpful, because many older printers only printed uppercase. Using consecutive ASCII characters saved computing power, because it was only necessary to add 32, without requiring a lookup table. Its use of most punctuation characters and the space character may limit its usefulness in some applications, such as those that use these characters as syntax.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (April 2016)">citation needed</span></a></i>]</sup></li>
<li><a href="https://en.wikipedia.org/wiki/BinHex" title="BinHex"><strong>BinHex 4</strong></a> (HQX), which was used within the <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS" title="Classic Mac OS">classic Mac OS</a>, excludes some visually confusable characters like ‘<code>7</code>‘, ‘<code>O</code>‘, ‘<code>g</code>‘ and ‘<code>o</code>‘. Its alphabet includes additional punctuation characters. It uses the alphabet “<code>!&quot;#$%&amp;&#39;()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr</code>“.</li>
<li>A <a href="https://en.wikipedia.org/wiki/UTF-8" title="UTF-8">UTF-8</a> environment can use non-synchronized continuation bytes as base64: <code>0b10**xxxxxx**</code>. See <a href="https://en.wikipedia.org/wiki/UTF-8#Comparison_with_other_encodings" title="UTF-8">UTF-8#Self-synchronization</a>.</li>
<li>Several other applications use alphabets similar to the common variations, but in a different order:<ul>
<li>Unix stores password hashes computed with <a href="https://en.wikipedia.org/wiki/Crypt_(C)" title="Crypt (C)"><strong>crypt</strong></a> in the <a href="https://en.wikipedia.org/wiki/Passwd#Password_file" title="Passwd"><code>/etc/passwd</code> file</a> using an encoding called B64. crypt’s alphabet puts the punctuation <code>.</code> and <code>/</code> before the alphanumeric characters. crypt uses the alphabet “<code>./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>“. Padding is not used.</li>
<li>The <strong><a href="https://en.wikipedia.org/wiki/GEDCOM" title="GEDCOM">GEDCOM</a></strong> 5.5 standard for genealogical data interchange encodes multimedia files in its text-line hierarchical file format. GEDCOM uses the same alphabet as crypt, which is “<code>./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>“.<sup id="cite_ref-17"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-17">[16]</a></sup></li>
<li><strong><a href="https://en.wikipedia.org/wiki/Bcrypt" title="Bcrypt">bcrypt</a></strong> hashes are designed to be used in the same way as traditional crypt(3) hashes, but bcrypt’s alphabet is in a different order than crypt’s. bcrypt uses the alphabet “<code>./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</code>“.<sup id="cite_ref-18"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-18">[17]</a></sup></li>
<li><strong><a href="https://en.wikipedia.org/wiki/Xxencoding" title="Xxencoding">Xxencoding</a></strong> uses a mostly-alphanumeric character set similar to crypt, but using <code>+</code> and <code>-</code> rather than <code>.</code> and <code>/</code>. Xxencoding uses the alphabet “<code>+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>“.</li>
<li><strong>6PACK</strong>, used with some <a href="https://en.wikipedia.org/wiki/Terminal_node_controller" title="Terminal node controller">terminal node controllers</a>, uses an alphabet from 0x00 to 0x3f.<sup id="cite_ref-19"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-19">[18]</a></sup></li>
<li><a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" title="Bash (Unix shell)"><strong>Bash</strong></a> supports numeric literals in Base64. Bash uses the alphabet “<code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_</code>“.<sup id="cite_ref-20"><a href="https://en.wikipedia.org/wiki/Base64#cite_note-20">[19]</a></sup></li>
</ul>
</li>
</ul>
<p>One issue with the RFC 4648 alphabet is that, when a sorted list of ASCII-encoded strings is Base64-transformed and sorted again, the order of elements changes. This is because the padding character and the characters in the substitution alphabet are not ordered by ASCII character value (which can be seen by using the following sample table’s sort buttons). Alphabets like (unpadded) <em>B64</em> address this.</p>
<table>
<thead>
<tr>
<th>ASCII</th>
<th>Base64</th>
<th>Base64, no padding</th>
<th>B64</th>
</tr>
</thead>
<tbody><tr>
<td><em>light w</em></td>
<td><code>bGlnaHQgdw==</code></td>
<td><code>bGlnaHQgdw</code></td>
<td><code>P4ZbO5EURk</code></td>
</tr>
<tr>
<td><em>light wo</em></td>
<td><code>bGlnaHQgd28=</code></td>
<td><code>bGlnaHQgd28</code></td>
<td><code>P4ZbO5EURqw</code></td>
</tr>
<tr>
<td><em>light wor</em></td>
<td><code>bGlnaHQgd29y</code></td>
<td><code>bGlnaHQgd29y</code></td>
<td><code>P4ZbO5EURqxm</code></td>
</tr>
</tbody></table>
<h2 id="See-also-edit"><a href="#See-also-edit" class="headerlink" title="See also[edit]"></a>See also[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=19" title="Edit section: See also">edit</a>]</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/8BITMIME" title="8BITMIME">8BITMIME</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ascii85" title="Ascii85">Ascii85</a> (also called Base85)</li>
<li><a href="https://en.wikipedia.org/wiki/Base16" title="Base16">Base16</a></li>
<li><a href="https://en.wikipedia.org/wiki/Base32" title="Base32">Base32</a></li>
<li><a href="https://en.wikipedia.org/wiki/Base36" title="Base36">Base36</a></li>
<li><a href="https://en.wikipedia.org/wiki/Base62" title="Base62">Base62</a></li>
<li><a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding" title="Binary-to-text encoding">Binary-to-text encoding</a> for a comparison of various encoding algorithms</li>
<li><a href="https://en.wikipedia.org/wiki/Binary_number" title="Binary number">Binary number</a></li>
<li><a href="https://en.wikipedia.org/wiki/URL" title="URL">URL</a></li>
</ul>
<h2 id="References-edit"><a href="#References-edit" class="headerlink" title="References[edit]"></a>References[<a href="https://en.wikipedia.org/w/index.php?title=Base64&action=edit&section=20" title="Edit section: References">edit</a>]</h2><ol>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-1" title="Jump up">^</a></strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding">“Base64 encoding and decoding – Web APIs”</a>. MDN Web Docs.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-2" title="Jump up">^</a></strong> <a href="https://www.davidbcalhoun.com/2011/when-to-base64-encode-images-and-when-not-to/">“When to base64 encode images (and when not to)”</a>. 28 August 2011.</li>
<li>^ <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-autogenerated2006_3-0">Jump up to: <sup><i><b>a</b></i></sup></a> <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-autogenerated2006_3-1"><sup><i><b>b</b></i></sup></a> <a href="https://datatracker.ietf.org/doc/html/rfc4648"><em>The Base16,Base32,and Base64 Data Encodings</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. October 2006. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC4648">10.17487&#x2F;RFC4648</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc4648">4648</a>. Retrieved March 18, 2010.</li>
<li>^ <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-rfc_1421_4-0">Jump up to: <sup><i><b>a</b></i></sup></a> <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-rfc_1421_4-1"><sup><i><b>b</b></i></sup></a> <a href="https://datatracker.ietf.org/doc/html/rfc1421"><em>Privacy Enhancement for InternetElectronic Mail: Part I: Message Encryption and Authentication Procedures</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. February 1993. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC1421">10.17487&#x2F;RFC1421</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1421">1421</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-rfc_2045_5-0" title="Jump up">^</a></strong> <a href="https://datatracker.ietf.org/doc/html/rfc2045"><em>Multipurpose Internet Mail Extensions: (MIME) Part One: Format of Internet Message Bodies</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. November 1996. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC2045">10.17487&#x2F;RFC2045</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2045">2045</a>. Retrieved March 18, 2010.</li>
<li>^ <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-rfc_3548_6-0">Jump up to: <sup><i><b>a</b></i></sup></a> <a href="https://en.wikipedia.org/wiki/Base64#cite_ref-rfc_3548_6-1"><sup><i><b>b</b></i></sup></a> <a href="https://datatracker.ietf.org/doc/html/rfc3548"><em>The Base16, Base32, and Base64 Data Encodings</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. July 2003. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC3548">10.17487&#x2F;RFC3548</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc3548">3548</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-8" title="Jump up">^</a></strong> <a href="https://datatracker.ietf.org/doc/html/rfc989"><em>Privacy Enhancement for Internet Electronic Mail</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. February 1987. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC0989">10.17487&#x2F;RFC0989</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc989">989</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-RFC_2045_9-0" title="Jump up">^</a></strong> Cite error: The named reference <code>RFC 2045</code> was invoked but never defined (see the <a href="https://en.wikipedia.org/wiki/Help:Cite_errors/Cite_error_references_no_text" title="Help:Cite errors/Cite error references no text">help page</a>).</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-10" title="Jump up">^</a></strong> <a href="https://datatracker.ietf.org/doc/html/rfc1642"><em>UTF-7 A Mail-Safe Transformation Format of Unicode</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. July 1994. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC1642">10.17487&#x2F;RFC1642</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc1642">1642</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-11" title="Jump up">^</a></strong> <a href="https://datatracker.ietf.org/doc/html/rfc2152"><em>UTF-7 A Mail-Safe Transformation Format of Unicode</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. May 1997. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC2152">10.17487&#x2F;RFC2152</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc2152">2152</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-12" title="Jump up">^</a></strong> <a href="https://datatracker.ietf.org/doc/html/rfc4880"><em>OpenPGP Message Format</em></a>. <a href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">IETF</a>. November 2007. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a href="https://doi.org/10.17487%2FRFC4880">10.17487&#x2F;RFC4880</a>. <a href="https://en.wikipedia.org/wiki/RFC_(identifier)" title="RFC (identifier)">RFC</a> <a href="https://datatracker.ietf.org/doc/html/rfc4880">4880</a>. Retrieved March 18, 2010.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-13" title="Jump up">^</a></strong> <a href="https://www.mentalfloss.com/article/77598/heres-why-youtube-will-never-run-out-unique-video-ids">“Here’s Why YouTube Will Practically Never Run Out of Unique Video IDs”</a>. <em><a href="http://www.mentalfloss.com/">www.mentalfloss.com</a></em>. 23 March 2016. Retrieved 27 December 2021.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-14" title="Jump up">^</a></strong> <a href="https://w3c.github.io/html/webappapis.html#atob">“7.3. Base64 utility methods”</a>. <em>HTML 5.2 Editor’s Draft</em>. <a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium" title="World Wide Web Consortium">World Wide Web Consortium</a>. Retrieved 2 January 2018. Introduced by <a href="https://html5.org/tools/web-apps-tracker?from=5813&to=5814">changeset 5814</a>, 2021-02-01.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-15" title="Jump up">^</a></strong> &lt;image xlink:href&#x3D;”data:image&#x2F;jpeg;base64,<code>JPEG contents encoded in Base64</code>“ … &#x2F;&gt;</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-16" title="Jump up">^</a></strong> <a href="http://jsfiddle.net/MxHPq/">“Edit fiddle”</a>. <em>jsfiddle.net</em>.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-17" title="Jump up">^</a></strong> <a href="https://homepages.rootsweb.ancestry.com/~pmcbride/gedcom/55gctoc.htm">“The GEDCOM Standard Release 5.5”</a>. Homepages.rootsweb.ancestry.com. Retrieved 2012-06-21.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-18" title="Jump up">^</a></strong> <a href="https://en.wikipedia.org/wiki/Niels_Provos" title="Niels Provos">Provos, Niels</a> (1997-02-13). <a href="https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/lib/libc/crypt/bcrypt.c?rev=1.1&content-type=text/x-cvsweb-markup">“src&#x2F;lib&#x2F;libc&#x2F;crypt&#x2F;bcrypt.c r1.1”</a>. Retrieved 2018-05-18.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-19" title="Jump up">^</a></strong> <a href="http://private.freepage.de/cgi-bin/feets/freepage_ext/41030x030A/rewrite/alexs/xfr/flexnet/6pack_en/6pack.htm">“6PACK a “real time” PC to TNC protocol”</a>. Retrieved 2013-05-19.</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Base64#cite_ref-20" title="Jump up">^</a></strong> <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html">“Shell Arithmetic”</a>. <em>Bash Reference Manual</em>. Retrieved 8 April 2020. Otherwise, numbers take the form [base#]n, where the optional base is a decimal number between 2 and 64 representing the arithmetic base, and n is a number in that base.</li>
</ol>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2023/03/20/GDB/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li>使用set print elements [n] 来更改打印字符串的长度。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set print elements 0</span><br><span class="line">(gdb) show print elements </span><br><span class="line">Limit on string chars or array elements to print is unlimited.</span><br><span class="line"></span><br><span class="line">(gdb) set print elements 300</span><br><span class="line">(gdb) show print elements</span><br><span class="line">Limit on string chars or array elements to print is 300.</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>GDB调试忽略信号</title>
    <url>/2023/03/19/GDB/%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="GDB调试忽略信号"><a href="#GDB调试忽略信号" class="headerlink" title="GDB调试忽略信号"></a>GDB调试忽略信号</h1><p>在linux平台，用gdb调试程序时，可以在gdb attach到运行中程序后，用以下命令忽略一些不关注的信号：</p>
<p>handle SIGUSR2 noprint nostop</p>
<p>handle SIGPIPE noprint nostop</p>
<p><img src="/images/GDB_1.png"></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>汇编调试</title>
    <url>/2023/03/19/GDB/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ol>
<li>打印寄存器的值:  <blockquote>
<p>i register</p>
</blockquote>
</li>
<li>打印所有寄存器的值:<blockquote>
<p>i all-registers</p>
</blockquote>
</li>
<li>打印单个寄存器的值<blockquote>
<p>i registers regname 或<br>p $regname”</p>
</blockquote>
</li>
<li>修改寄存器的值<blockquote>
<p><strong>例子</strong></p>
</blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;       </span><br><span class="line">        int a =0;               </span><br><span class="line"></span><br><span class="line">        a++;    </span><br><span class="line">        a++;    </span><br><span class="line">        printf(&quot;%d\n&quot;, a);      </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   PC寄存器会存储程序下一条要执行的指令，通过修改这个寄存器的值，可以达到改变程序执行流程的目的。上面的程序会输出“a&#x3D;2”，下面介绍一下如何通过修改PC寄存器的值，改变程序执行流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4               int a =0;</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x08050921 &lt;main+0&gt;:    push   %ebp</span><br><span class="line">0x08050922 &lt;main+1&gt;:    mov    %esp,%ebp</span><br><span class="line">0x08050924 &lt;main+3&gt;:    sub    $0x8,%esp</span><br><span class="line">0x08050927 &lt;main+6&gt;:    and    $0xfffffff0,%esp</span><br><span class="line">0x0805092a &lt;main+9&gt;:    mov    $0x0,%eax</span><br><span class="line">0x0805092f &lt;main+14&gt;:   add    $0xf,%eax</span><br><span class="line">0x08050932 &lt;main+17&gt;:   add    $0xf,%eax</span><br><span class="line">0x08050935 &lt;main+20&gt;:   shr    $0x4,%eax</span><br><span class="line">0x08050938 &lt;main+23&gt;:   shl    $0x4,%eax</span><br><span class="line">0x0805093b &lt;main+26&gt;:   sub    %eax,%esp</span><br><span class="line">0x0805093d &lt;main+28&gt;:   movl   $0x0,-0x4(%ebp)</span><br><span class="line">0x08050944 &lt;main+35&gt;:   lea    -0x4(%ebp),%eax</span><br><span class="line">0x08050947 &lt;main+38&gt;:   incl   (%eax)</span><br><span class="line">0x08050949 &lt;main+40&gt;:   lea    -0x4(%ebp),%eax</span><br><span class="line">0x0805094c &lt;main+43&gt;:   incl   (%eax)</span><br><span class="line">0x0805094e &lt;main+45&gt;:   sub    $0x8,%esp</span><br><span class="line">0x08050951 &lt;main+48&gt;:   pushl  -0x4(%ebp)</span><br><span class="line">0x08050954 &lt;main+51&gt;:   push   $0x80509b4</span><br><span class="line">0x08050959 &lt;main+56&gt;:   call   0x80507cc &lt;printf@plt&gt;</span><br><span class="line">0x0805095e &lt;main+61&gt;:   add    $0x10,%esp</span><br><span class="line">0x08050961 &lt;main+64&gt;:   mov    $0x0,%eax</span><br><span class="line">0x08050966 &lt;main+69&gt;:   leave</span><br><span class="line">0x08050967 &lt;main+70&gt;:   ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) info line 6</span><br><span class="line">Line 6 of &quot;a.c&quot; starts at address 0x8050944 &lt;main+35&gt; and ends at 0x8050949 &lt;main+40&gt;.</span><br><span class="line">(gdb) info line 7</span><br><span class="line">Line 7 of &quot;a.c&quot; starts at address 0x8050949 &lt;main+40&gt; and ends at 0x805094e &lt;main+45&gt;.</span><br></pre></td></tr></table></figure>

<p>通过“info line 6”和“info line 7”命令可以知道两条“a++;”语句的汇编指令起始地址分别是0x8050944和0x8050949。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">6               a++;</span><br><span class="line">(gdb) p $pc</span><br><span class="line">$3 = (void (*)()) 0x8050944 &lt;main+35&gt;</span><br><span class="line">(gdb) set var $pc=0x08050949</span><br></pre></td></tr></table></figure>

<p>当程序要执行第一条“a++;”语句时，打印pc寄存器的值，看到pc寄存器的值为0x8050944，与“info line 6”命令得到的一致。接下来，把pc寄存器的值改为0x8050949，也就是通过“info line 7”命令得到的第二条“a++;”语句的起始地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">8               printf(&quot;a=%d\n&quot;, a);</span><br><span class="line">(gdb)</span><br><span class="line">a=1</span><br><span class="line">9               return 0;</span><br></pre></td></tr></table></figure>

<p>接下来执行，可以看到程序输出“a&#x3D;1”，也就是跳过了第一条“a++;”语句。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/10/GDB/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><p>如何在gdb中加载多个符号<a href="https://www.itbaoku.cn/tag/file" title="文件">文件</a>.我有一个可执行的foo.out和加载模块栏.我创建了两个符号文件foo.symbol和bar.symbol.如何将两个文件加载到GDB中.</p>
<p># gdb –core core</p>
<h1 id="gdb"><a href="#gdb" class="headerlink" title="(gdb)"></a>(gdb)</h1><h1 id="gdb-symbol-file-foo-symbol"><a href="#gdb-symbol-file-foo-symbol" class="headerlink" title="(gdb) symbol-file foo.symbol"></a>(gdb) symbol-file foo.symbol</h1><p>如何加载第二个符号文件.或有什么方法可以加载gdb</p>
<p>中的所有目录文件</p>
<h2 id="推荐答案"><a href="#推荐答案" class="headerlink" title="推荐答案"></a>推荐答案</h2><p>设置包含符号文件的目录use</p>
<p>set debug-file-directory <directory></directory></p>
<p>并使用</p>
<p>show debug-file-directory</p>
<p>显示当前设置为包含符号文件的目录.</p>
<p>符号文件是从此目录自动读取的，如果二进制文件以<a href="https://www.itbaoku.cn/tag/debugging" title="调试">调试</a>链接为单位.</p>
<p>二进制文件.</p>
<ul>
<li></li>
</ul>
<p>要添加其他符号，您可能会使用add-symbol-<a href="https://www.itbaoku.cn/tag/file" title="file">file</a>.</p>
<p>(如 <a href="https://sourceware.org/gdb/gdb/onlinedocs/gdb/">gdb onlinedocs</a> 目前我在这里引用此信息，</p>
<blockquote>
<p>附加符号文件的文件名地址</p>
<p>附加符号文件文件名地址[-readNow] [ - 映射]</p>
<p>附加符号文件文件名-Ssection地址…</p>
<p>附加符号文件命令从文件文件名中读取其他符号表信息.当将文件名(通过某些其他方式)动态加载到正在运行的程序中时，您将使用此命令.地址应为已加载文件的内存地址； GDB无法自行解决这个问题.您还可以指定任意数量的``ssection地址’’对，以提供该节的明确截面名称和基础地址.您可以将任何地址指定为表达式.</p>
<p>文件文件名的符号表被添加到最初使用符号文件命令读取的符号表中.您可以多次使用附加符号文件命令；因此，新的符号数据读取不断添加到旧.为了丢弃所有旧符号数据，请使用没有任何参数的符号文件命令.</p>
<p>尽管文件名通常是共享库文件，可执行文件或已完全重新安置以加载到过程中的其他对象文件，但您也可以从重新定位的.o文件加载符号信息，只要:</p>
<ul>
<li>文件的符号信息仅指该文件中定义的链接器符号，而不是由其他对象文件定义的符号，</li>
<li>每节文件的符号信息涉及实际上已加载到文件中，并且</li>
<li>您可以确定每个部分加载的地址，并将其提供给附加符号文件命令.</li>
</ul>
<p>一些嵌入式操作系统，例如Sun Chorus和VXWorks，可以将可重定位的文件加载到已经运行的程序中；这样的系统通常使上述要求易于满足.但是，重要的是要认识到，许多天然系统都使用复杂的链接程序(例如，链接部分分解和C ++构造函数组件)，使要求难以满足.通常，不能假设使用附加符号文件读取可重新定位对象文件的符号信息的效果与将可重定位对象文件链接到程序中的效果相同.</p>
<p>.</p>
<p>加上符号文件在使用后不重复.</p>
<p>与符号文件命令一样，您可以使用-mapped’ and -ReadNow’选项，以更改GDB管理文件名的符号表信息.</p>
</blockquote>
<h2 id="其他推荐答案"><a href="#其他推荐答案" class="headerlink" title="其他推荐答案"></a>其他推荐答案</h2><p>其他符号可以加载到gdb调试会话:</p>
<p>add-symbol-file filename address</p>
<p>参数address是.text节的地址.可以通过以下方式检索此地址</p>
<p>readelf -WS path&#x2F;to&#x2F;file.elf | grep .text | awk ‘{ print “0x”$5 }’</p>
<p>可以通过在gdb中自动化这可以通过添加以下输入到~&#x2F;.gdbinit:</p>
<p>来自动化.</p>
<p>define add-symbol-file-auto</p>
<h1 id="Parse-text-address-to-temp-file"><a href="#Parse-text-address-to-temp-file" class="headerlink" title="Parse .text address to temp file"></a>Parse .text address to temp file</h1><p>  shell echo set \$text_address&#x3D;$(readelf -WS $arg0 | grep .text | awk ‘{ print “0x”$5 }’) &gt;&#x2F;tmp&#x2F;temp_gdb_text_address.txt</p>
<h1 id="Source-text-address"><a href="#Source-text-address" class="headerlink" title="Source .text address"></a>Source .text address</h1><p>  source &#x2F;tmp&#x2F;temp_gdb_text_address.txt</p>
<h1 id="Clean-tempfile"><a href="#Clean-tempfile" class="headerlink" title="Clean tempfile"></a>Clean tempfile</h1><p>  shell rm -f &#x2F;tmp&#x2F;temp_gdb_text_address.txt</p>
<h1 id="Load-symbol-table"><a href="#Load-symbol-table" class="headerlink" title="Load symbol table"></a>Load symbol table</h1><p>  add-symbol-file $arg0 $text_address<br>end</p>
<p>以上功能定义add-symbol-file-auto可以使用其他符号:</p>
<p>(gdb) add-symbol-file-auto path&#x2F;to&#x2F;bootloader.elf<br>add symbol table from file “path&#x2F;to&#x2F;bootloader.elf” at<br>    .text_addr &#x3D; 0x8010400<br>(gdb) add-symbol-file-auto path&#x2F;to&#x2F;application.elf<br>add symbol table from file “path&#x2F;to&#x2F;application.elf” at<br>    .text_addr &#x3D; 0x8000000<br>(gdb) break main<br>Breakpoint 1 at 0x8006cb0: main. (2 locations)<br>(gdb) info break<br>Num     Type           Disp Enb Address    What<br>1       breakpoint     keep y   <MULTIPLE><br>1.1                         y     0x08006cb0 in main() at .&#x2F;source&#x2F;main.cpp:114<br>1.2                         y     0x080106a6 in main() at .&#x2F;main.cpp:10<br>(gdb)</MULTIPLE></p>
]]></content>
  </entry>
  <entry>
    <title>输出日志记录</title>
    <url>/2023/02/16/GDB/%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="输出日志记录"><a href="#输出日志记录" class="headerlink" title="输出日志记录"></a>输出日志记录</h1><blockquote>
<p>(gdb) set logging file fileName 设置文件名，文件默认生成在运行gdb命令的目录下；<br>(gdb) set logging on 启动日志记录；<br>(gdb) set height 0 这样gdb需要多行输出时，就会全部输出，中间不会暂停；<br>(gdb) set print elements 0 这样gdb在打印时就没有默认为200个元素的长度限制；<br>(gdb) thread apply all bt 在这里去实际操作，所需要的gdb命令<br>(gdb) set logging off  </p>
</blockquote>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>Do not edit</title>
    <url>/2023/09/10/GDB/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDB&gt; show scheduler-locking //显示线程的scheduler-locking状态</span><br><span class="line">GDB&gt; set scheduler-locking on //调试加锁当前线程，停止所有其他线程</span><br><span class="line">GDB&gt; set print pretty on //格式化打印</span><br><span class="line">GDB&gt; thread find [regexp] //查找线程</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Do not edit</category>
      </categories>
  </entry>
  <entry>
    <title>Questions</title>
    <url>/2023/03/21/Questions/%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="脚本问题"><a href="#脚本问题" class="headerlink" title="脚本问题"></a>脚本问题</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ol>
<li>windows脚本不断重复执行同一条命令<br>原因: 脚本名和cmd系统命令重复</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/2023/02/24/Shortcuts/vscode/</url>
    <content><![CDATA[<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><ol>
<li>Ctrl + D 或 Ctrl + Shift + L<br>选中所有相同选项, 一起修改</li>
</ol>
]]></content>
      <categories>
        <category>Shortcuts</category>
      </categories>
  </entry>
  <entry>
    <title>Hash</title>
    <url>/2023/03/19/Redis/Hash/</url>
    <content><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>Redis4.0之前使用的Hash算法是MurmurHash, 即使输入的键是有规律的, 该算法计算的结果依然有很好的离散性, 并且计算速度非常快. Redis4.0开始更换为SipHash算法, 应该是出于安全的考虑, 该算法能有效防止Hash表碰撞<br>攻击, 并提供不错的性能</p>
<blockquote>
<h3 id="SipHash"><a href="#SipHash" class="headerlink" title="SipHash"></a>SipHash</h3><p>大部分非加密哈希算法的改良，都集中在让哈希速度更快更好上。SipHash 则是个异类，它的提出是为了<a href="http://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">解决一类安全问题</a>：hash flooding。通过让&gt; 输出随机化，SipHash 能够有效减缓 hash flooding 攻击。凭借这一点，它逐渐成为 Ruby、Python、Rust 等语言默认的 hash 表实现的一部分。<br>如果你愿意尝试下新技术，可以看看 2016 新出的 <a href="https://github.com/google/highwayhash">HighwayHash</a>。它宣称可以达到 SipHash 一样的效果，并且凭借 SIMD 的加持，在运算速度上它是 SipHash 的 5.2 倍（参考来源：<a href="https://arxiv.org/abs/1612.06257">https://arxiv.>  org/abs/1612.06257</a> ）。</p>
</blockquote>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>把ht[0]上的数据迁移到ht[1]shang</p>
<p>size调整为2的n次幂, 为了ht[1]Hash表数据长度是ht[0]Hash表数据长度的倍数, 有利于ht[0]的数据均匀地迁移到ht[1]</p>
<p><strong>Hash&amp;ht.sizemask, sizemask&#x3D;size-1, idx&#x3D;hash%(ht.size)</strong>, 因此, 假如ht[0].size为0, ht[1].size&#x3D;2*n, 对于ht[0]上的元素, ht[0].table[k]的数据, 要不迁移到ht[1].table[k], 要不迁移到ht[1].table[k+n]</p>
<h2 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h2><p>执行删除操作后, Redis会检查字典是否需要缩容, 当Hash表长度大于4且负载因子小于0.1时, 会执行缩容操作, 以节省内存</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis字典使用SipHash算法计算Hash值, 并使用链表法处理Hash冲突<br>Redis字段使用渐进式扩容方法, 在每次数据操作中都执行一次扩容单步操作, 直到扩容完成<br>散列类型的编码格式可以为OBJ_ENCODING_HT, OBJ_ENCODING_ZIPLIST  </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>分割线语法</title>
    <url>/2023/02/12/Markdown/%E5%88%86%E5%89%B2%E7%BA%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown分割线语法"><a href="#Markdown分割线语法" class="headerlink" title="Markdown分割线语法"></a>Markdown分割线语法</h1><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure>

<p>以上三个分隔线的渲染效果看起来都一样：</p>
<ul>
<li></li>
</ul>
<h3 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="# 分隔线（Horizontal Rule）用法最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%88%86%E9%9A%94%E7%BA%BF%EF%BC%88horizontal-rule%EF%BC%89%E7%94%A8%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 分隔线（Horizontal Rule）用法最佳实践</h3><p>为了兼容性，请在分隔线的前后均添加空白行。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;Try to put a blank line before…</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="…and-after-a-horizontal-rule-Without-blank-lines-this-would-be-a-heading"><a href="#…and-after-a-horizontal-rule-Without-blank-lines-this-would-be-a-heading" class="headerlink" title="…and after a horizontal rule.|Without blank lines, this would be a heading.  "></a>…and after a horizontal rule.<code>|</code>Without blank lines, this would be a heading.  </h2><p>Don’t do this!&#96; |</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2023/03/19/Redis/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="无序集合"><a href="#无序集合" class="headerlink" title="无序集合"></a>无序集合</h2><p>Redis通常使用字典结构保存用户集合数据, 字典键存储集合元素, 字典值为空. 如果一个集合全是整数, 则使用字典过于浪费内存, 为此, Redis设计了intset数据结构, 专门用来保存整数集合数据</p>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合即数据都是有序的. 存储一组有序收据, 最简单的是一下两种结构:<br>(1) 数据, 可以通过二分法查找数据, 但插入数据的复杂度为O(n)<br>(2) 链表, 可以快速插入数据, 但无法使用二分查找, 查找数据的复杂度为O(n)<br>兼具上面两种结构的优点的数据结构, <strong>跳表skiplist</strong></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>skiplist是一个多层级的链表结构</p>
<p><img src="/../images/Redis_1.webp"></p>
<h3 id="为什么使用skiplist"><a href="#为什么使用skiplist" class="headerlink" title="为什么使用skiplist"></a>为什么使用skiplist</h3><p>红黑树也常用于维护有序数据, 为什么使用skiplist</p>
<ol>
<li>skiplist虽然以空间换时间, 但没有过度占用内存, 内存使用率在合理范围内</li>
<li>有序集合常常需要执行ZRANGE或ZREVRANGE等遍历操作, 使用skiplist可以更高效地实现这些操作(skiplist第一层的双向链表可以遍历数据)</li>
<li>skiplist实现简单</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>任务列表语法</title>
    <url>/2023/02/12/Markdown/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="任务列表语法"><a href="#任务列表语法" class="headerlink" title="任务列表语法"></a>任务列表语法</h1><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<ul>
<li><input checked disabled type="checkbox"> Write the press release</li>
<li><input disabled type="checkbox"> Update the website</li>
<li><input disabled type="checkbox"> Contact the media</li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>msg</title>
    <url>/2023/03/28/Redis/msg/</url>
    <content><![CDATA[<h1 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h1><ol>
<li>skiplist</li>
<li>cpu绑定</li>
<li>unix编程</li>
<li>事件机制</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>删除线语法</title>
    <url>/2023/02/12/Markdown/%E5%88%A0%E9%99%A4%E7%BA%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="删除线语法"><a href="#删除线语法" class="headerlink" title="删除线语法"></a>删除线语法</h1><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来<del>像这样</del>。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号<code>~~</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<p><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>定义列表</title>
    <url>/2023/02/12/Markdown/%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h1><p><strong>vs code 无效</strong></p>
<p>一些Markdown处理器允许您创建术语及其对应定义的_定义列表_。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure>

<p>HTML看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;First Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt;</span><br><span class="line">  &lt;dt&gt;Second Term&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt;</span><br><span class="line">  &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<dl><dt>First Term</dt><dd>This is the definition of the first term.</dd></dl><dl><dt>Second Term<br>: This is one definition of the second term.</dt><dd>This is another definition of the second term.</dd></dl>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>强调语法</title>
    <url>/2023/02/12/Markdown/%E5%BC%BA%E8%B0%83%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown强调语法"><a href="#Markdown强调语法" class="headerlink" title="Markdown强调语法"></a>Markdown强调语法</h1><p>通过将文本设置为粗体或斜体来强调其重要性。</p>
<h2 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="# 粗体（Bold）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89">#</a> 粗体（Bold）</h2><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>I just love **bold text**.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>I just love __bold text__.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>Love**is**bold</code></td>
<td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td>
<td>Love<strong>is</strong>bold</td>
</tr>
</tbody></table>
<h3 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="# 粗体（Bold）用法最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E7%94%A8%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 粗体（Bold）用法最佳实践</h3><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>Love**is**bold</code></td>
<td><code>Love__is__bold</code></td>
</tr>
</tbody></table>
<h2 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="# 斜体（Italic）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89">#</a> 斜体（Italic）</h2><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>Italicized text is the *cat&#39;s meow*.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>Italicized text is the _cat&#39;s meow_.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>A*cat*meow</code></td>
<td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td>
<td>A_cat_meow</td>
</tr>
</tbody></table>
<h3 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="# 斜体（Italic）用法的最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89%E7%94%A8%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 斜体（Italic）用法的最佳实践</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>A*cat*meow</code></td>
<td><code>A_cat_meow</code></td>
</tr>
</tbody></table>
<h2 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="# 粗体（Bold）和斜体（Italic）"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E5%92%8C%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89">#</a> 粗体（Bold）和斜体（Italic）</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>This text is ***really important***.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is ___really important___.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is __*really important*__.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is **_really important_**.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td>
<td>This is really**<em>very</em>**important text.</td>
</tr>
</tbody></table>
<h3 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="# 粗体（Bold）和斜体（Italic）用法的最佳实践"></a><a href="https://markdown.com.cn/basic-syntax/emphasis.html#%E7%B2%97%E4%BD%93%EF%BC%88bold%EF%BC%89%E5%92%8C%E6%96%9C%E4%BD%93%EF%BC%88italic%EF%BC%89%E7%94%A8%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">#</a> 粗体（Bold）和斜体（Italic）用法的最佳实践</h3><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody><tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really___very___important text.</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>转义字符语法</title>
    <url>/2023/02/12/Markdown/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-转义字符语法"><a href="#Markdown-转义字符语法" class="headerlink" title="Markdown 转义字符语法"></a>Markdown 转义字符语法</h1><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p>* Without the backslash, this would be a bullet in an unordered list.</p>
<h3 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="# 可做转义的字符"></a><a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#%E5%8F%AF%E5%81%9A%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6">#</a> 可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Name</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>backslash</td>
</tr>
<tr>
<td>`</td>
<td>backtick (see also <a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#escaping-backticks">escaping backticks in code</a>)</td>
</tr>
<tr>
<td>*</td>
<td>asterisk</td>
</tr>
<tr>
<td>_</td>
<td>underscore</td>
</tr>
<tr>
<td>{ }</td>
<td>curly braces</td>
</tr>
<tr>
<td>[ ]</td>
<td>brackets</td>
</tr>
<tr>
<td>( )</td>
<td>parentheses</td>
</tr>
<tr>
<td>#</td>
<td>pound sign</td>
</tr>
<tr>
<td>+</td>
<td>plus sign</td>
</tr>
<tr>
<td>-</td>
<td>minus sign (hyphen)</td>
</tr>
<tr>
<td>.</td>
<td>dot</td>
</tr>
<tr>
<td>!</td>
<td>exclamation mark</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="# 特殊字符自动转义"></a><a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89">#</a> 特殊字符自动转义</h2><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T</code>」 ，还得转换网址内的 <code>&amp;</code> 符号，如果你要链接到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;q=larry+bird</span><br></pre></td></tr></table></figure>

<p>你必须要把网址转成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;amp;q=larry+bird</span><br></pre></td></tr></table></figure>

<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
<p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 <code>&amp;</code> 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 <code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;copy;</span><br></pre></td></tr></table></figure>

<p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;T</span><br></pre></td></tr></table></figure>

<p>Markdown 就会将它转为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;amp;T</span><br></pre></td></tr></table></figure>

<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="https://markdown.com.cn/basic-syntax/#%E5%86%85%E8%81%94-html">行内 HTML</a> ，如果你使用 <code>&lt;</code> 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &lt; 5</span><br></pre></td></tr></table></figure>

<p>Markdown 将会把它转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &amp;lt; 5</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体。）</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>表格语法</title>
    <url>/2023/02/12/Markdown/%E8%A1%A8%E6%A0%BC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdwon表格语法"><a href="#Markdwon表格语法" class="headerlink" title="Markdwon表格语法"></a>Markdwon表格语法</h1><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
<p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure>

<p><strong>Tip:</strong> 使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="# 对齐"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%AF%B9%E9%BD%90">#</a> 对齐</h2><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure>

<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
<th>Test Text</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
<td>Here’s this</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
<td>And more</td>
</tr>
</tbody></table>
<h2 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="# 格式化表格中的文字"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97">#</a> 格式化表格中的文字</h2><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（<code>`</code>）中的单词或短语，而不是代码块）和强调。</p>
<p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p>
<h2 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="# 在表中转义管道字符"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%9C%A8%E8%A1%A8%E4%B8%AD%E8%BD%AC%E4%B9%89%E7%AE%A1%E9%81%93%E5%AD%97%E7%AC%A6">#</a> 在表中转义管道字符</h2><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>语法速查表</title>
    <url>/2023/03/19/Markdown/%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Markdown-语法速查表-Markdown-官方教程"><a href="#Markdown-语法速查表-Markdown-官方教程" class="headerlink" title="Markdown 语法速查表 | Markdown 官方教程"></a>Markdown 语法速查表 | Markdown 官方教程</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>Markdown 速查表提供了所有 Markdown 语法元素的基本解释。如果你想了解某些语法元素的更多信息，请参阅更详细的 基本语法 和 扩展语法.</p>
</blockquote>
<hr>
<h2 id="总览"><a href="#总览" class="headerlink" title="# 总览"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E6%80%BB%E8%A7%88">#</a> 总览</h2><p>Markdown 速查表提供了所有 Markdown 语法元素的基本解释。如果你想了解某些语法元素的更多信息，请参阅更详细的 <a href="https://markdown.com.cn/basic-syntax">基本语法</a> 和 <a href="https://markdown.com.cn/extended-syntax">扩展语法</a>.</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="# 基本语法"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">#</a> 基本语法</h2><p>这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>Markdown 语法</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://markdown.com.cn/basic-syntax/headings.html">标题（Heading）</a></td>
<td><code># H1   ## H2   ### H3</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/bold.html">粗体（Bold）</a></td>
<td><code>**bold text**</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/italic.html">斜体（Italic）</a></td>
<td><code>*italicized text*</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/blockquotes.html">引用块（Blockquote）</a></td>
<td><code>&gt; blockquote</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/ordered-lists.html">有序列表（Ordered List）</a></td>
<td><code>1. First item</code></td>
</tr>
<tr>
<td></td>
<td><code>2. Second item</code></td>
</tr>
<tr>
<td></td>
<td><code>3. Third item</code></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/unordered-lists.html">无序列表（Unordered List）</a></td>
<td><code>- First item   - Second item   - Third item   </code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/code.html">代码（Code）</a></td>
<td><code>`code`</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html">分隔线（Horizontal Rule）</a></td>
<td><code>---</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/links.html">链接（Link）</a></td>
<td><code>[title](https://www.example.com)</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/basic-syntax/images.html">图片（Image）</a></td>
<td><code>![alt text](image.jpg)</code></td>
</tr>
</tbody></table>
<h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="# 扩展语法"></a><a href="https://markdown.com.cn/cheat-sheet.html#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">#</a> 扩展语法</h2><p>这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>Markdown 语法</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://markdown.com.cn/extended-syntax/tables.html">表格（Table）</a></td>
<td>&#96;</td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/fenced-code-blocks.html">代码块（Fenced Code Block）</a></td>
<td><code>```   &#123;     &quot;firstName&quot;: &quot;John&quot;,     &quot;lastName&quot;: &quot;Smith&quot;,     &quot;age&quot;: 25   &#125;   ```</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/footnotes.html">脚注（Footnote）</a></td>
<td>Here’s a sentence with a footnote. <code>[^1]</code></td>
</tr>
<tr>
<td><code>[^1]</code>: This is the footnote.</td>
<td></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/heading-ids.html">标题编号（Heading ID）</a></td>
<td><code>### My Great Heading &#123;#custom-id&#125;</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/definition-lists.html">定义列表（Definition List）</a></td>
<td><code>term   : definition</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/strikethrough.html">删除线（Strikethrough）</a></td>
<td><code>~~The world is flat.~~</code></td>
</tr>
<tr>
<td><a href="https://markdown.com.cn/extended-syntax/task-lists.html">任务列表（Task List）</a></td>
<td><code>- [x] Write the press release   - [ ] Update the website   - [ ] Contact the media</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Do not edit</title>
    <url>/2024/06/02/Shell/for/</url>
    <content><![CDATA[<h1 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h1><p>Windows bat脚本的for语句基本形态如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在cmd窗口中：<span class="keyword">for</span> %I <span class="title function_">in</span> <span class="params">(command1)</span> <span class="keyword">do</span> command2 在批处理文件中：<span class="keyword">for</span> %%I <span class="title function_">in</span> <span class="params">(command1)</span> <span class="keyword">do</span> command2</span><br></pre></td></tr></table></figure>

<p>之所以要区分cmd窗口和批处理文件两种环境，是因为在这两种环境下，命令语句表现出来的行为虽然基本一样，但是在细节上还是稍有不同，最明显的一个差异就是：在cmd窗口中，for之后的形式变量I必须使用单百分号引用，即%I；而在批处理文件中，引用形式变量I必须使用双百分号，即%%I。为了方便起见，若不是特别强调，以下的讲解都以批处理文件环境为例。</p>
<p>我们先来看一下for语句的基本要素都有些什么：</p>
<ol>
<li>for、in和do是for语句的关键字，它们三个缺一不可；</li>
<li>%%I是for语句中对形式变量的引用，即使变量l在do后的语句中没有参与语句的执行，也是必须出现的；</li>
<li>in之后，do之前的括号不能省略；</li>
<li>command1表示字符串或变量，command2表示字符串、变量或命令语句；</li>
</ol>
<p>  下面来看一个Windows bat脚本的demo(记为demo1)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">echo</span> off</span><br><span class="line"><span class="keyword">for</span>  %%I <span class="title function_ invoke__">in</span> (ABC) <span class="keyword">do</span> <span class="keyword">echo</span> %%I</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p> 保存为.bat文件(批处理文件)并执行，将会在弹出的批处理窗口中看到这样的信息：</p>
<p><img src="//img-blog.csdn.net/20180320184647370">  </p>
<p> 对批处理文件的for循环就是这样简单，下面来看看for语句的注意事项，并运行更复杂的for循环实例。</p>
<ol>
<li><p>for语句的形式变量I，可以换成26个字母中的任意一个，这些字母会区分大小写，也就是说，%%I和%%i会被认为不是同一个变量；形式变量I还可以换成其他的字符，但是，为了不与批处理中的%0～%9这10个形式变量发生冲突，请不要随意把%%I替换为%%0～%%9中的任意一个；</p>
</li>
<li><p>in和do之间的command1表示的字符串或变量可以是一个，也可以是多个，每一个字符串或变量，我们称之为一个元素，每个元素之间，用空格键、跳格键、逗号、分号或等号分隔；</p>
</li>
<li><p>for语句依次提取command1中的每一个元素，把它的值赋予形式变量I，带到do后的command2中参与命令的执行；并且每次只提取一个元素，然后执行一次do后的命令语句，而无论这个元素是否被带到command2中参与了command2的运行；当执行完一次do后的语句之后，再提取command1中的下一个元素，再执行一次command2，如此循环，直到command1中的所有元素都已经被提取完毕，该for语句才宣告执行结束。</p>
<p> 有了以上的基础，我们再来看下面这个例子，这个例子修改了demo1中的部分内容(记为demo2)，结果将大不一样：</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">echo</span> off</span><br><span class="line"><span class="keyword">for</span>  %%I <span class="title function_ invoke__">in</span> (A,B,C) <span class="keyword">do</span> <span class="keyword">echo</span> %%I</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>  运行结果如下：</p>
<p><img src="//img-blog.csdn.net/20180320184632835">  </p>
<p>如果把 bbs.bathome.cn 这个字符串中的点号换为空格、跳格或等号，执行结果将和demo2的执行结果别无二致。</p>
<p>现在，来分析一下demo2代码中for语句的执行过程：</p>
<p>  1.for语句以逗号为分隔符，把 A,B,C 这个字符串切分成三个元素：A、B和C，由此决定了do后的语句将会被执行3次；   </p>
<p> 2.第一次执行过程是这样的：先把 bbs 这个字符串作为形式变量I的值，带入do后的语句中加以执行，也就是执行 echo %%I 语句，此时的I值为A，因此，第一次执行的结果，将会在屏幕上显示A这个字符串；第二次执行和第一次执行的过程是一样的，只不过此时I的值已经被替换为command1中的第二个元素了，也就是 B 这个字符串；如此循环，当第三次echo执行完毕之后，整条for语句才算执行完毕，此时，将执行下一条语句，也就是pause命令。</p>
<p> 高级用法：</p>
<p>1)搜索当前目录下有哪些文件？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for %%i in (*.*) do echo &quot;%%i&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>2)搜索当前目录下所有的文本文件？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">for %%i in (*.txt) do echo &quot;%%i&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Do not edit</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/02/Shell/dd/</url>
    <content><![CDATA[<h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><a href="https://so.csdn.net/so/search?q=dd%E5%91%BD%E4%BB%A4&spm=1001.2101.3001.7020">dd命令</a>,主要功能为转换和复制文件。<br>在Linux中，硬件的设备驱动和特殊设备文件 也是文件；dd也可以直接读取或写入到这些文件。<br>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<p>块是衡量一次读取、写入和转换字节的单位。命令行选项可以为输入&#x2F;读取（ibs）和输出&#x2F;写入（<a href="https://so.csdn.net/so/search?q=obs&spm=1001.2101.3001.7020">obs</a>）指定一个不同的块大小，尽管块大小（bs）选项会覆盖ibs和obs选项。输入和输出的默认块大小为512字节（传统的磁盘块及POSIX规定的“块”大小）复制的count选项。</p>
<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul>
<li>if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</li>
<li>of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</li>
<li>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</li>
<li>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li>
<li>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
<li>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。<br>  注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li>
<li>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
<li>conv&#x3D;conversion：用指定的参数转换文件。</li>
<li>ascii：转换ebcdic为ascii</li>
<li>ebcdic：转换ascii为ebcdic</li>
<li>ibm：转换ascii为alternate ebcdic</li>
<li>block：把每一行转换为长度为cbs，不足部分用空格填充</li>
<li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li>
<li>lcase：把大写字符转换为小写字符</li>
<li>ucase：把小写字符转换为大写字符</li>
<li>swab：交换输入的每对字节</li>
<li>noerror：出错时不停止</li>
<li>notrunc：不截短输出文件</li>
<li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li>
</ul>
<h2 id="dd-示例"><a href="#dd-示例" class="headerlink" title="dd 示例"></a>dd 示例</h2><p>1.将本地的&#x2F;dev&#x2F;hdb整盘备份到&#x2F;dev&#x2F;hdd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/hdb of=/dev/hdd</span><br></pre></td></tr></table></figure>

<p>2.将&#x2F;dev&#x2F;hdb全盘数据备份到指定路径的image文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/hdb of=/root/image</span><br></pre></td></tr></table></figure>

<p>3.将备份文件恢复到指定盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/root/image of=/dev/hdb</span><br></pre></td></tr></table></figure>

<p>4.备份&#x2F;dev&#x2F;hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/hdb | gzip &gt; /root/image.gz</span><br></pre></td></tr></table></figure>

<p>5.将压缩的备份文件恢复到指定盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -dc /root/image.gz | <span class="built_in">dd</span> of=/dev/hdb</span><br></pre></td></tr></table></figure>

<p>6.备份与恢复MBR<br>备份磁盘开始的512个字节大小的MBR信息到指定文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/hda of=/root/image count=1 bs=512</span><br><span class="line">count=1指仅拷贝一个块；bs=512指块大小为512个字节。</span><br></pre></td></tr></table></figure>

<p>恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/root/image of=/dev/had</span><br><span class="line">将备份的MBR信息写到磁盘开始部分</span><br></pre></td></tr></table></figure>

<p>7.备份软盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/fd0 of=disk.img count=1 bs=1440k (即块大小为1.44M)</span><br></pre></td></tr></table></figure>

<p>8.拷贝内存内容到硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/mem of=/root/mem.bin bs=1024 (指定块大小为1k)</span><br></pre></td></tr></table></figure>

<p>9.拷贝光盘内容到指定文件夹，并保存为cd.iso文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom(hdc) of=/root/cd.iso</span><br></pre></td></tr></table></figure>

<p>10.增加swap分区文件大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">第一步：创建一个大小为256M的文件：</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1024 count=262144</span><br><span class="line">第二步：把这个文件变成swap文件：</span><br><span class="line">mkswap /swapfile</span><br><span class="line">第三步：启用这个swap文件：</span><br><span class="line">swapon /swapfile</span><br><span class="line">第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件：</span><br><span class="line">/swapfile swap swap default 0 0</span><br></pre></td></tr></table></figure>

<p>11.销毁磁盘数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/hda1</span><br></pre></td></tr></table></figure>

<p>注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。</p>
<p>12.测试硬盘的读写速度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/root/1Gb.file bs=64k | <span class="built_in">dd</span> of=/dev/null</span><br></pre></td></tr></table></figure>

<p>通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。</p>
<p>13.确定硬盘的最佳块大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=2048 count=500000 of=/root/1Gb.file</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=4096 count=250000 of=/root/1Gb.file</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</span><br></pre></td></tr></table></figure>

<p>通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。</p>
<p>14.修复硬盘：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/sda 或<span class="built_in">dd</span> <span class="keyword">if</span>=/dev/hda of=/dev/hda</span><br></pre></td></tr></table></figure>

<p>当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I&#x2F;O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的。</p>
<p>15.将一个很大的视频文件中的第i个字节的值改成0x41（也就是大写字母A的ASCII值）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> A | <span class="built_in">dd</span> of=bigfile seek=<span class="variable">$i</span> bs=1 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Shell IF语法</title>
    <url>/2023/03/19/Shell/if/</url>
    <content><![CDATA[<h1 id="SHELL-IF-语法"><a href="#SHELL-IF-语法" class="headerlink" title="SHELL IF 语法"></a>SHELL IF 语法</h1><p>if [ -f file ]; then<br>   echo “yes yes yes”<br>elif [ -z file ]; then<br>   echo “yes yes”<br>else<br>   echo “nonono”<br>fi</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/02/Shell/windows/</url>
    <content><![CDATA[<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><ol>
<li>win10命令行打开当前文件夹界面的方法</li>
</ol>
<p>命令行进入文件夹后执行</p>
<blockquote>
<p>explore.exe .</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>read</title>
    <url>/2023/03/20/Shell/read/</url>
    <content><![CDATA[<h1 id="read"><a href="#read" class="headerlink" title="read"></a>read</h1><p>linux shell从键盘获取输入</p>
<p><strong>代码1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line">  </span><br><span class="line">#提示“Input your choice:”，把用户的输入保存入变量choice\_user中  </span><br><span class="line">read -p &quot;Input your choice:&quot; choice\_user   </span><br><span class="line">echo &quot;your choice:$&#123;choice\_user&#125;&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">#提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中  </span><br><span class="line">read -t 30 -p &quot;请输入用户名称:&quot; name  </span><br><span class="line">echo -e &quot;\\n&quot;  </span><br><span class="line">echo &quot;用户名为:$name&quot;  </span><br><span class="line">  </span><br><span class="line">#提示“请输入密码”并等待30秒，把用户的输入保存入变量age中，输入内容隐藏  </span><br><span class="line">read -t 30 -s -p &quot;请输入用户密码:&quot; age  </span><br><span class="line">echo -e &quot;\\n&quot;  </span><br><span class="line">echo &quot;用户密码为:$age&quot;  </span><br><span class="line">  </span><br><span class="line">#提示“请输入性别”并等待30秒，把用户的输入保存入变量sex中，只接受一个字符输入  </span><br><span class="line">read -t 30 -n 1 -p &quot;请输入用户性别:&quot; sex  </span><br><span class="line">echo -e &quot;\\n&quot;  </span><br><span class="line">echo &quot;性别为$sex&quot;</span><br><span class="line"></span><br><span class="line">**read命令说明：**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">read \[选项\]\[变量名\]  </span><br><span class="line">选项：  </span><br><span class="line">  </span><br><span class="line">Read的一些选项  </span><br><span class="line">Read可以带有-a, -d, -e, -n, -p, -r, -t, 和 -s八个选项。</span><br><span class="line"></span><br><span class="line">\-a ：将内容读入到数值中  </span><br><span class="line">echo -n &quot;Input muliple values into an array:&quot;  </span><br><span class="line">read -a array  </span><br><span class="line">echo &quot;get $&#123;#array\[@\]&#125; values in array&quot;  </span><br><span class="line">\-d ：表示delimiter，即定界符，一般情况下是以IFS为参数的间隔，但是通过-d，我们可以定义一直读到出现执行的字符位置。例如read –d madfds value，读到有m的字符的时候就不在继续向后读，例如输入为 hello m，有效值为“hello”，请注意m前面的空格等会被删除。这种方式可以输入多个字符串，例如定义“.”作为结符号等等。  </span><br><span class="line">\-e ：只用于互相交互的脚本，它将readline用于收集输入行。 </span><br><span class="line">\-n ：用于限定最多可以有多少字符可以作为有效读入。例如echo –n 4 value1 value2，如果我们试图输入12 34，则只有前面有效的12 3，作为输入，实际上在你输入第4个字符‘3’后，就自动结束输入。这里结果是value为12，value2为3。  </span><br><span class="line">\-p ：用于给出提示符，在前面的例子中我们使用了echo –n “…“来给出提示符，可以使用read –p ‘… my promt?’value的方式只需一个语句来表示。  </span><br><span class="line">\-r ：在参数输入中，我们可以使用’/’表示没有输入完，换行继续输入，如果我们需要行最后的’/’作为有效的字符，可以通过-r来进行。此外在输入字符中，我们希望/n这类特殊字符生效，也应采用-r选项。  </span><br><span class="line">\-s ：对于一些特殊的符号，例如箭头号，不将他们在terminal上打印，例如read –s key，我们按光标，在回车之后，如果我们要求显示，即echo，光标向上，如果不使用-s，在输入的时候，输入处显示^\[\[A，即在terminal上打印，之后如果要求echo，光标会上移。  </span><br><span class="line">\-t ：用于表示等待输入的时间，单位为秒，等待时间超过，将继续执行后面的脚本，注意不作为null输入，参数将保留原有的值。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/2023/03/20/Shell/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ol>
<li>杀死进程</li>
</ol>
<p>#####查找tomcat进程<br>ps -ef | grep tomcat | grep -v grep | awk ‘{print $2}’<br>#####查找tomcat进程并杀死<br>ps -ef | grep tomcat | grep -v grep | awk ‘{print $2}’ | xargs kill -9  </p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2023/02/12/Markdown/%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown-使用"><a href="#Markdown-使用" class="headerlink" title="Markdown 使用"></a>Markdown 使用</h1><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h3 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="# 多个段落的块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%A4%9A%E4%B8%AA%E6%AE%B5%E8%90%BD%E7%9A%84%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
<h3 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="# 嵌套块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%B5%8C%E5%A5%97%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h3 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="# 带有其它元素的块引用"></a><a href="https://markdown.com.cn/basic-syntax/horizontal-rules.html#%E5%B8%A6%E6%9C%89%E5%85%B6%E5%AE%83%E5%85%83%E7%B4%A0%E7%9A%84%E5%9D%97%E5%BC%95%E7%94%A8">#</a> 带有其它元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; #### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<blockquote>
<h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/02/Shell/%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="SHELL-调试方法选项"><a href="#SHELL-调试方法选项" class="headerlink" title="SHELL 调试方法选项"></a>SHELL 调试方法选项</h1><h2 id="Shell本身提供一些调试方法选项："><a href="#Shell本身提供一些调试方法选项：" class="headerlink" title="Shell本身提供一些调试方法选项："></a>Shell本身提供一些调试方法选项：</h2><ol>
<li>-n，读一遍脚本中的命令但不执行，用于检查脚本中的语法错误。</li>
<li>-v，一边执行脚本，一边将执行过的脚本命令打印到标准输出。</li>
<li>-x，提供跟踪执行信息，将执行的每一条命令和结果依次打印出来。</li>
</ol>
<h2 id="使用这些选项有三种方法-注意-避免几种调试选项混用"><a href="#使用这些选项有三种方法-注意-避免几种调试选项混用" class="headerlink" title="使用这些选项有三种方法(注意:避免几种调试选项混用)"></a>使用这些选项有三种方法(注意:避免几种调试选项混用)</h2><ol>
<li>在命令行提供参数：sh -x script.sh 或者 bash -n script.sh</li>
<li>脚本开头提供参数：#!&#x2F;bin&#x2F;sh -x 或者 #!&#x2F;bin&#x2F;bash -x</li>
<li>在脚本中用set命令启用或者禁用参数，其中set -x表示启用，set +x表示禁用</li>
</ol>
<p><strong>set命令的详细说明</strong></p>
<ul>
<li><a href="http://man.linuxde.net/set">http://man.linuxde.net/set</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-set.html">https://www.runoob.com/linux/linux-comm-set.html</a></li>
</ul>
<p><strong>Bash 官网文档</strong></p>
<ul>
<li>bash <a href="https://www.gnu.org/software/bash/">https://www.gnu.org/software/bash/</a></li>
<li>Bash-Reference-Manual <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html</a></li>
</ul>
]]></content>
  </entry>
</search>
